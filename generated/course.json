key: aave-developer-1
title: AAVE Developer 1 (In Progress)
summary: >
  This is a technical course for developers willing to write applications on
  AAVE.
details: >-
  In this course we cover the following

  1) Chapter 1 - Information about various smart contracts of AAVE

  2) Chapter 2 - How to pull data from AAVE which can be used to create
  analytics applications
duration: 1 - 2 hours
highlights:
  - AAVE Smart Contract Introduction
  - Fetching AAVE Data
  - Developer Environment Setup
  - Writing simple UI application on top of AAVE
publishStatus: Live
thumbnail: https://d31h13bdjwgzxs.cloudfront.net/courses/DoDAO/DeFi/defi_logo.jpeg
topics:
  - title: AAVE Smart Contracts
    key: aave-smart-contracts
    details: >
      This chapter taks about various important smart contracts of AAVE which
      forms the basis of lending and borrowing
    order: 0
    explanations:
      - title: Introduction
        shortTitle: Introduction
        key: aave-smart-contracts-intro
        details: >
          Aave is a decentralized finance protocol that facilitates lending and
          borrowing of cryptocurrency tokens usAave ing diverse algorithms and
          smart contracts without the presence of centralized intermediaries. 

          It is a non-custodial liquidity protocol that allows users to
          participate as depositors or borrowers. Depositors provide liquidity
          to the market to earn a passive income, while borrowers are able to
          borrow in an overcollateralized manner.


          Aave's transition from a decentralized P2P lending approach (a direct
          loan relationship between lenders and borrowers, similar to ETHLend)
          to a pool-based strategy is marked by the creation of the Aave
          Protocol. By putting cryptocurrency in a pool contract, lenders offer
          liquidity. The pooled funds can also be borrowed inside the same
          contract by pledging collateral. Loans rely on the pooled money as
          well as the quantities borrowed and their collateral rather than on
          individual matching. This makes it possible to quickly lend money with
          terms that depend on the condition of the pool. Figure 1 below shows a
          simplified version of the protocol's structure.


          ![AAVE](https://github.com/DoDAO-io/dodao-aave-developer-1-course/blob/6bd13f67bbb027bc58280c103f78b0b29d5ad810/images/aave.jpg?raw=true)

          `Reference: https://docs.aave.com/developers/v/2.0/`


          The participants lending the tokens get interest on their loan and the
          participants borrowing the tokens pay interest. An individual can lend
          and borrow simultaneously via Aave.

          The working mechanism of Aave involves allocating a platform specific
          token, called aTokens to a user's crypto investment. 

          This is what lenders get when they deposit their assets into the pool.

          For instance, a user who deposits Ethereum in Aave will hold aETH on
          Aave. 

          aToken is based on a particular crypto asset and the interest rate
          each aToken earns is specific to the token deposited, depending on the
          supply and demand for the original coin.


          Aave Protocol was created with security in mind and has been audited
          by various auditors.

          The White Paper provides a more in-depth look at the protocol,
          economics, and how it operates.

          On Github, the Aave Protocol repository can be found here:
          https://github.com/aave/.


          #### Lending and borrowing

          Aave has a smart contract based working mechanism wherein the interest
          rates are determined by different algorithms.

          The depositors lend the funds in the liquidity pools and earn
          interest, similarly borrowers can borrow the funds from the liquidity
          pools. 


          The interest rate for both borrowers and lenders is decided
          algorithmically:


          * **Interest rate for Borrowers**: The interest rate to be paid by the
          borrowers depends on the cost of money and the amount of funds
          available in the pool at a specific time.The amount of funds present
          in the pool has an inverse relationship with the interest rate. As
          funds are borrowed from the pool, the amount of funds available
          decreases which raises the interest rate. 


          * **Interest rate for Lenders**: The interest rate received by the
          lenders corresponds to the earn rate, with the algorithm safeguarding
          a liquidity reserve to guarantee withdrawals at any time.


          And since cryptocurrency is highly volatile, borrowing in Aave demands
          overcollateralization. 

          For example-  Kevin wants to borrow $500 worth of ETH from the AAve
          protocol. In order to do so, Kevin will have to put up more than that
          amount in a different cryptocurrency. If the price falls and the
          amount in collateral no longer covers the amount borrowed, the
          collateral can be liquidated, meaning the protocol takes it to cover
          the cost of the loan.

          A liquidation event happens when the price of the collateral drops
          below the liquidation threshold.
      - title: Important Tech Terms
        shortTitle: Tech Terms
        key: terminology
        details: >
          * **APY**: Annual Percentage Yield is the yield/interest after a year,
          including compounding interest. This differs from the Annual
          Percentage Rate (APR), which does not account for compounding effects.


          * **Liquidity Index**: The reserve's interest accumulation during the
          time span since the last updated timestamp.


          * **Loan To Value**: The maximum borrowing capacity of a particular
          collateral. If a collateral has a Loan to Value of 75%, the user will
          be allowed to borrow 0.75 ETH of primary currency for every 1 ETH of
          collateral. The Loan To Value is represented in percentage points and
          is set per collateral.


          * **Liquidation Threshold**: The amount of a borrow position that must
          be liquidated because it is undercollateralized. When a collateral has
          an 80% liquidation threshold, it signifies that the loan will be
          liquidated when the debt value equals 80% of the collateral value. The
          liquidation threshold is defined in percentage points and is specified
          per collateral.


          * **Liquidation Bonus**: The bonus paid to liquidators to encourage
          the purchase of specified collateral with a health factor less than
          one. The Liquidation Bonus is defined in percentage points and is
          determined per collateral.


          * **Health factor**: The ratio of total collateral multiplied by the
          liquidation threshold to borrowed principal. When the Health Factor
          falls below one, the loan is considered undercollateralized and can be
          liquidated.


          * **Stable rate**: A loan with a stable rate behaves like a fixed rate
          loan in the short term, but the rates can be rebalanced in the
          medium/long term in response to rapid market movements.


          * **Reserve** : Reserves are the underlying assets' ERC-20 contracts.


          * **Variables in Code**

          Following is the list of most common variables used in the code:


          | Parameter Name             | Type            |
          Description                                                                                                                                           
          |

          | -------------------------- | --------------- |
          ------------------------------------------------------------------------------------------------------------------------------------------------------
          |

          | reserve                    | address         | address of the
          [underlying
          asset](https://docs.aave.com/developers/v/1.0/deployed-contracts/deployed-contract-instances#reserves-assets)              
          |

          | amount                     | uint256         | amount to
          borrow/deposit/repay, expressed in decimal
          units                                                                                            
          |

          | referralCode               | uint256         | referral code for the
          referral
          program                                                                                                                
          |

          | useAsCollateral            | bool            | if true, the asset is
          allowed as a collateral for
          borrow                                                                                              
          |

          | interestRateMode           | uint256         | type of interest rate
          mode to use, with uint 2 representing variable rate and uint 1
          representing stable rate                                          |

          | onBehalfOf                 | address payable | address to repay on
          behalf of. If the caller is repaying their own loan, then this value
          should be equal to msg.sender                                 |

          | user                       | address         | address of the user
          to
          rebalance                                                                                                                      
          |

          | collateral                 | address         | address of the
          liquidated collateral
          reserve                                                                                                          
          |

          | purchaseAmount             | uint256         | amount of the
          discounted
          purchase                                                                                                                     
          |

          | receiveaToken              | bool            | if true, the user
          receives the aTokens equivalent of the purchased collateral. If false,
          the user receives the underlying asset directly               |

          | timestamp                  | uint256         | timestamp of the
          transaction, in Unix
          time                                                                                                            
          |

          | borrowRateMode             | uint256         | interest rate mode 0
          for None, 1 for stable and 2 for
          variable                                                                                        
          |

          | borrowRate                 | uint256         | APY of the loan at
          the time of the borrow() call. in
          Wei.                                                                                             
          |

          | originationFee             | uint256         | amount of the
          originationFee of the loan, in [Ray
          units](https://docs.aave.com/developers/v/1.0/developing-on-aave/important-considerations#ray-math).
          |

          | borrowBalanceIncrease      | uint256         | amount of debt
          increased since the last update by the user, in
          Wei.                                                                                   
          |

          | repayer                    | uint256         | address of the
          repayer                                                                                                                                
          |

          | amountMinusFees            | uint256         | amount repayed,
          without
          fees.                                                                                                                         
          |

          | fees                       | uint256         | fees
          paid                                                                                                                                             
          |

          | purchaseAmount             | uint256         | amount of the
          liquidation, in
          Wei.                                                                                                                    
          |

          | liquidatedCollateralAmount | uint256         | amount of collateral
          being
          liquidated                                                                                                                 
          |

          | accruedBorrowInterest      | uint256         | amount of debt
          increased since the last update by the user, in
          Wei.                                                                                   
          |

          | liquidator                 | address         | address of the
          liquidator                                                                                                                             
          |

          | receiveAToken              | bool            | true if the
          liquidator wants to receive aTokens, false
          otherwise.                                                                                     
          |
      - title: AAVE Architecture
        shortTitle: Architecture
        key: architecture
        details: >
          Aave has released three versions (v1, v2 and v3) as of now and the
          Governance token of Aave is "AAVE". Version 1 or v1 is the base
          version launched in 2017 and then there have been upgrades with
          multiple new features added. 

          Aave v2 improves on many areas of v1, allowing developers to create a
          wide new design space in which to construct products and services. If
          you previously developed on Aave v1, you should be aware of the
          following changes:

          * There is no longer a LendingPoolCore contract in Aave v2 that
          retains all of the protocol's assets. Assets are held directly in the
          linked aToken contracts, with the LendingPool contract serving as the
          protocol's "core."

          * Almost all actions in Aave v2 should be executed via the LendingPool
          contract. This differs from v1, when a redemption/withdrawal of
          aTokens required a call on the aToken contract.

          * After depositing collateral into the protocol, a user can easily
          delegate credit to any address by using approveDelegation() on the
          relevant debt token.

          * Flash loans are possible inside the Aave v2 protocol. Indeed, they
          are widely utilised within the protocol for position switching and
          other 'trading'-like functions.

          * Flash loans can now be executed in batches, which means that many
          flash loans with varied parameters can be performed in the same call.
          This opens the door to strong new use cases, such as repaying numerous
          assets and positions with a single flash loan transaction.

          * You can now do a combination of 'conventional' flash loans that are
          paid back instantly and flash loans that incur debt (i.e. the flash
          loan is not paid back immediately).

          * AddressesProviders will be numerous in multiple markets. The
          AddressesProviderRegistry will keep track of all Aave market address
          providers.

          * LendingPoolCore has been decommissioned. Only LendingPool is used,
          which simplifies integrations and Aave v2 development.

          The v3 improved features enable new use cases, sparking a flood of
          innovation from users and developers. Aave V3 generates I mprovements
          in all of the these areas - capital efficiency, security,
          decentralisation, and UX - while simultaneously delivering new
          functions to harness the capabilities of rollups and the developing
          ecosystem of rival L1s.

          * Portal is a new set of core functionalities that can be utilised to
          enable provided assets to move easily between Aave markets on
          different networks. On the surface, the feature is fairly simple: the
          protocol uses the aTokens' unique pegged design to burn aTokens on the
          source network while minting them on the destination network.

          * Borrowers can use High Efficiency Mode (E-Mode) to get the most
          borrowing power out of their collateral. Borrowers can use E-Mode to
          limit their borrowing to only assets in a specific category (e.g.,
          stablecoins).

          * One of the most important areas for improvement is managing the
          inherent complexities of risk exposure modulation.

          * Repay with aTokens: Allows borrowers to repay with aTokens rather
          than the underlying asset.

          * Despite all of the new features, the overall gas cost of all
          functions fell by about 25%.

          * Smart contract re-engineering has considerably reduced code size
          (leaving more room for future revisions) by up to 100K optimizer runs!

          * All token transfer functions (supply, repay) now support EIP 2612
          authorization (this is especially important for L2).

          * Signature on EIP 712 for credit delegation (no need for contracts to
          request a user transaction anymore).


          #### Protocol Overview


          On Github, the Aave Protocol repository can be found here:
          https://github.com/aave/

          Below image provides an overview of the protocol.


          ![Architecture](https://github.com/DoDAO-io/dodao-aave-developer-1-course/blob/6bd13f67bbb027bc58280c103f78b0b29d5ad810/images/architechture.png?raw=true)

          `Reference:
          https://docs.aave.com/developers/v/2.0/the-core-protocol/protocol-overview`


          #### Main Contracts

          The main contracts in Aave and their purposes are:

          * LendingPool: The main entry point into the Aave Protocol. Most
          interactions with Aave will happen via the LendingPool, including:
            - deposit()
            - borrow()
            - repay()
            - swapBorrowRateMode()
            - setUserUseReserveAsCollateral()
            - withdraw()
            - flashloan()
            - liquidationCall()
          * LendingPoolAddressesProvider: The protocol's primary addresses
          register for specific marketplaces. The most recent contract addresses
          should be obtained from this contract by making the necessary calls.

          * LendingPoolAddressesProviderRegistry: Contains a list of active
          LendingPoolAddressesProvider addresses, for different markets.

          * aTokens: The yield-producing, tokenized deposits that are used
          throughout the Aave protocol. They implement, with minor
          modifications, the majority of the standard EIP-20/ERC20 token
          methods, as well as Aave-specific methods such as:
            - scaledBalanceOf()
            - getScaledUserBalanceAndSupply()
            - scaledTotalSupply()
            All aTokens also implement EIP-2612, which via the permit() function enables gas-less transfers and single transaction approve + actions.
          * Stable and Variable Debt Tokens: The Aave protocol employs tokenised
          borrow locations throughout. Because debt tokens are non-transferable,
          most common EIP-20/ERC20 techniques are disabled.


          #### Supporting contracts

          The following contracts should generally not be interacted with
          directly, but are used throughout the Aave Protocol via contract
          calls.

          * LendingPoolCollateralManager: The LendingPoolCollateralManager
          implements protocol activities involving collateral management using
          delegatecall via the LendingPool contract, including:
            - liquidationCall()
          Only the primary LendingPool contract should be used to call the above
          function.

          * Lending Pool Configurator: Configuration functions for LendingPool
          contracts are provided. It also serves a variety of vital purposes:
            - Activates / Deactivates reserves,
            - Enables / Disables borrowing for a reserve,
            - Enables / Disables using a reserve as collateral,
            - Enables / Disables stable rate borrowing for a reserve,
            - Freezes / Unfreezes reserves,
            - Updates a reserve's Loan to Value,
            - Updates a reserve's liquidation threshold,
            - Updates a reserve's liquidation bonus,
            - Updates a reserve's decimals,
            - Updates a reserve's interest rate strategy address,
            - Activates / Deactivates all functions of a LendingPool in emergencies.
            For all of the above functions, relevant events are emitted to the blockchain. Anyone can monitor these changes to know when values have been modified or added/removed.
          * Interest Rate Strategy: Contains the data required to calculate and
          adjust the interest rates on individual reserves.

          Each contract stores the optimised base curves using the relevant
          currency parameters. This means that each asset pool's interest rate
          is determined by a mathematical function, with the interest rate
          varying based on the amount of borrowed funds and the asset pool's
          total liquidity (i.e. utilisation).

          The parameters for the optimised base curves are:
            - baseVariableBorrowRate
            - variableRateSlope1
            - variableRateSlope2
            - stableRateSlope1
            - stableRateSlope2
          The interest rates are calculated depending on the available liquidity
          and the total borrowed amount.
      - title: AAVE Functionalities in Details - I
        shortTitle: Functions - I
        key: functions-1
        details: >
          The LendingPool contract is the protocol's principal contract. It
          exposes all user-oriented operations that may be performed with the
          Solidity or web3 libraries. The source code is available
          [here](https://github.com/aave/aave-protocol/blob/master/contracts/lendingpool/LendingPool.sol).

          To concentrate on method interactions, Web3 code samples remove
          imports and transactional sections. Join the #developers channel on
          the [Aave community Discord server](https://discord.gg/fVaDMqT) if you
          require development assistance.


          #### Deposit/Lending

          Lenders share the interest payments made by borrowers based on the
          utilization rate multiplied by the average borrowing rate. The yield
          for depositors increases as reserve utilization increases.

          Lenders are also entitled to a portion of the Flash Loan fees, equal
          to 0.09% of the Flash Loan volume.

          There is no minimum or maximum deposit amount; you may deposit any
          amount you choose.


          #### Methods

          #### deposit()

          **function deposit( address _reserve, uint256 _amount, uint16
          _referralCode)**

          Deposits a certain _amount of an asset specified by the _reserve
          parameter.

          In exchange, the caller receives a specific number of aTokens. aTokens
          can be redeemed for the underlying token in a 1:1 ratio.

          Please see the referral programme section for further information
          about _referralCode input. You can use the referral code: 0 during
          testing.

          When depositing an ERC-20 token, the LendingPoolCore contract (not the
          LendingPool contract) must have the required allowance of _amount for
          the underlying ERC20 of the _reserve asset via approve().

          Emitted events: _reserve, _user, _amount, _referral, _timestamp


          **ETH deposits**

          Because the protocol does not employ an EIP-20 wrapper like wETH for
          ETH deposits, the deposit() method's amount parameter must match the
          transaction's msg.value parameter and be included in your deposit()
          call.

          E.g: lendingPool.deposit{ value: msg.value }(reserve, msg.value,
          referralCode)

          Because ETH is utilised directly in the protocol (rather than an
          abstraction like WETH), we use a dummy address to represent it:
          0xEeeeeEeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee


          **ERC20 deposits**

          The _reserve parameter corresponds to the underlying asset's ERC20
          contract address.


          Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L753


          The deposit() flow within the protocol:

          https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH4HvCIm09jkjFv%2Flending%20pool%20deposit.png?alt=media&token=c92f8256-9d73-41a1-9e96-a3d807425d08 


          #### setUserUseReserveAsCollateral()

          **function setUserUseReserveAsCollateral(address _reserve, bool
          _useAsCollateral)**

          Allow the user's deposit to be used as collateral. Users will only be
          able to disable deposits that are not being used as collateral at the
          time.

          Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L341 


          **Stable vs Variable Interest Rate**

          In the short-term, stable rates function as a fixed rate, but they can
          be rebalanced in the long run in reaction to alterations in the market
          environment. Depending on supply and demand in Aave, the variable rate
          can change.

          The stable rate is the better choice for forecasting how much interest
          you will have to pay because, as its name suggests, it will remain
          fairly stable. The variable rate changes over time and, depending on
          market conditions, could be the optimal rate.
      - title: AAVE Functionalities in Details - II
        shortTitle: Functions - II
        key: functions-2
        details: >
          #### Borrow

          You must deposit any asset to be used as collateral before
          borrowing.The amount you can borrow depends on the value you have
          deposited and the readily available liquidity.For instance, if there
          isn’t enough liquidity or if your health factor (minimum threshold of
          the collateral = 1, below this value, liquidation of your collateral
          is triggered) prevents it, you can’t borrow an asset. The loan is
          repaid with the same asset that you borrowed.

          For instance, if you borrow 1 ETH, you’ll need to pay back 1 ETH plus
          interest.

          In the updated Version 2 of the Aave Protocol, you can also use your
          collateral to make payments. You can borrow any of the stablecoins
          like USDC, DAI, USDT, etc. if you want to repay the loan based on the
          price of the USD.


          #### Methods

          #### borrow()

          **function borrow(address _reserve, uint256 _amount, uint256
          _interestRateMode, uint16 _referralCode)** 

          Transfers a certain amount of the asset identified by the _reserve
          parameter to the msg.sender, provided the caller has deposited enough
          collateral to fund the borrow in advance.

          Every loan can be opened in either a fixed or variable rate mode.
          Borrows have an indefinite term and no payback date. In the event of
          market swings, a borrow position is liquidated if the collateral price
          falls below a specific threshold. Please read the White Paper to learn
          more about the stable rate economy.

          Please see the [referral programme
          section](https://docs.aave.com/developers/v/1.0/integrating-aave/referral-program)
          for further information about _referralCode input. You can use the
          referral code: 0 during testing.

          Emitted events: _reserve, _user, _amount, _referral, _timestamp,
          _borrowRateMode, _borrowRate, _originationFee, _borrowBalanceIncrease


          Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L219 


          The borrow() flow within the protocol:

          https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH3GOEvYvbizwHC%2Flending%20pool%20borrow.png?alt=media&token=2031b536-733e-4a8a-866c-23c86706e641 


          #### repay()

          **function repay( address _reserve, uint256 _amount, address payable
          _onBehalfOf)**

          Repay a borrowed asset in whole or in part. The _onBehalfOf parameter
          can be used to repay a different user's debt.

          When a third-party repays another user's debt on their behalf, the
          third-party address must approve() the LendingPoolCore contract (which
          is separate from the LendingPool contract) with the _amount of the
          underlying ERC20 of the _reserve contract.

          Emitted events: _reserve, _user, _repayer, _fees, _referral,
          _timestamp, _amountMinusFees, _borrowBalanceIncrease


          Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L249 


          The repay() flow within the protocol: 

          https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH9NighH7i_73lI%2Flending%20pool%20repay.png?alt=media&token=cb6e102e-222b-412a-92f0-763ae34e7cce 


          #### swapBorrowRateMode()

          **function swapBorrowRateMode(address _reserve)**

          Changes the borrow rate modes of the msg.sender from stable to
          variable.

          Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L326 


          #### rebalanceStableBorrowRate()

          **function rebalanceStableBorrowRate(address _reserve, address
          _user)**

          Rebalances the stable rate of _user

          Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L336 


          The rebalance flow for stable rates in the protocol:
          https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH7rY4WFE5jRwrB%2Flending%20pool%20rebalancing.png?alt=media&token=8a442d62-6087-4adf-b27b-163478547f79 


          #### liquidationCall()

          **function liquidationCall(address _collateral, address _reserve,
          address _user, uint256 _purchaseAmount, bool _receiveaToken)**

          Positions with a health factor less than one should be liquidated.

          When a position's health factor falls below one, liquidators repay
          part or all of the outstanding borrowed amount on behalf of the
          borrower in exchange for a discounted quantity of collateral
          (sometimes known as a liquidation "bonus"). Liquidators have the
          option of receiving an equal quantity of collateral aTokens or the
          underlying asset directly. When the liquidation is completed
          successfully, the position's health factor is enhanced, bringing it
          above 1.

          A close factor determines how much collateral a liquidator can close.
          The current close factor is 0.5. In other words, liquidators can only
          liquidate up to 50% of the amount owing in a position. This is the
          amount of the liquidation discount.

          Liquidators must approve() the LendingPoolCore contract (which is
          distinct from the LendingPool contract) in order to use the underlying
          ERC20 of the _reserve asset for the liquidation.

          **NOTE**: In most cases, profitable liquidators will choose to
          liquidate as much of the _user position as possible.

          purchaseAmount parameter can be set to uint(-1) and the protocol will
          proceed with the largest liquidation allowed by the close factor.

          For ETH liquidations, the transaction's msg.value should be identical
          to the _purchaseAmount parameter.

          To determine a user's health factor, use getUserAccountData().

          Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L360 


          The liquidation flow in the protocol:

          https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH6dX0q9LDXBn9X%2Flending%20pool%20liquidation.png?alt=media&token=6701e381-1fd1-42ce-919b-39da57434c57 
      - title: AAVE Functionalities in Details - III
        shortTitle: Functions - III
        key: functions-3
        details: >
          Flash Loans are special transactions that allow you to borrow an asset
          as long as the borrowed amount (plus a fee) is returned before the
          transaction ends (also called One Block Borrows). These transactions
          do not necessitate the provision of collateral by the user prior to
          the transaction. Because there is no real-world equivalent for Flash
          Loans, some basic grasp of how the state is managed within blocks in
          blockchains is required.

          Due to the technical understanding necessary to execute one, flash
          loans are a feature developed for developers. To use this feature, you
          must have a solid understanding of EVM, programming, and smart
          contracts. To do a Flash Loan, you must first create a contract
          requesting a Flash Loan. The contract must follow the instructions and
          repay the loan plus interest and fees in the same transaction.


          Can you use Flash Loans without knowing how to code?

          Yes, there are currently programs available that enable end users to
          gain from Flash Loans, such as [defisaver](https://defisaver.com/) and
          [collateralswap](https://collateralswap.com/). At
          https://medium.com/aave/sneak-peek-at-flash-loans-f2b28a394d62 , you
          may find more application cases.

          Even those without coding experience may use Flash Loans because of
          user interfaces like the one [furucombo](https://furucombo.app/)
          offers. Details are provided below:
          https://medium.com/furucombo/create-flashloan-combo-on-furucombo-c7c3b23267f0 


          Aave v3 provides two flash loan options:

          **flashLoan**: Allows the borrower to obtain liquidity from various
          reserves in a single flashLoan transaction. In this instance, the
          borrower has the option of opening a stable or variable rate debt
          position backed by supplied collateral or credit delegation.

          **NOTE**: For qualified flashBorrowers, the loan charge is waived
          (managed by ACLManager)

          **flashLoanSimple**: Allows the borrower to access a single reserve of
          liquidity for the transaction. In this situation, the flash loan fee
          is not waived, and the borrower is not permitted to open any debt
          positions at the conclusion of the transaction. For individuals
          attempting to take advantage of a simple flash loan with a single
          reserve asset, this strategy is gas efficient.


          #### Flow of Execution

          A helpful mental model to consider when creating your solution for
          developers:

          * Your contract contacts the Pool contract and requests a Flash Loan
          for a specific amount(s) of reserve(s) using flashLoanSimple() or
          flashLoan() ().

          * The Pool sends the requested amounts of reserves to your contract
          after some sanity checks, then executes executeOperation() on the
          receiver contract.

          * Your contract now does any arbitrary operation in its code while
          holding the flash borrowed amount(s).

          * When you finish your code for a flashLoanSimple, you approve Pool
          for the flash loaned amount + charge.

          * If you are executing flashLoan, then all reserves must be granted
          for flash borrowed amount + fee or adequate collateral or credit
          delegation must be provided to start debt position, based on the
          interestRateMode passed for the asset.

          * If the amount owed is not available (due to a lack of balance or
          authorisation, or insufficient debt collateral), the transaction is
          reverted.

          * All of the preceding occurs in a single transaction (hence in a
          single ethereum block).


          #### Flash Loan Applications

          Aave Flash Loans are already used for the liquidity swap functionality
          in Aave V3. Other real-world instances include: arbitrage between
          assets without requiring the main amount to be present.

          Liquidating borrow positions without having to repay the debt of the
          positions and paying off flashLoan amount + charge with discounted
          collateral claimed.


          #### Fee for a Flash loan

          The flash loan charge is set to 0.09% at deployment and can be changed
          via Governance Vote. To obtain the current value, use FLASHLOAN
          PREMIUM TOTAL.

          The LPs (liquidity providers) and the protocol treasury can split the
          flashloan charge. The FLASHLOAN PREMIUM TOTAL variable represents the
          total charge paid by borrowers, which includes:

          Fee to LP: FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL

          Fee to Protocol: FLASHLOAN_PREMIUM_TO_PROTOCOL

          At initialization, FLASHLOAN_PREMIUM_TO_PROTOCOL is 0.


          #### First step: Setting Up

          By implementing the relevant executeOperation() function, your
          contract that receives the amounts from flash loans must comply with
          the IFlashLoanSimpleReceiver.sol or IFlashLoanReceiver.sol interface.

          Additionally, keep in mind that since the owing sums will be deducted
          from your contract, your contract must let the Pool to deduct those
          monies in order to repay the flash loan amount plus premiums.


          #### Second Step: Calling flashLoan() or flashLoanSimple()

          To invoke either of the Pool's two flash lending methods, we must
          provide the necessary parameters. There are three possibilities:

          * From an EOA ('normal' Ethereum account)
            - To use an EOA, send a transaction to the appropriate Pool and use the flashLoan() or flashLoanSimple() functions. For parameter information, see the Pool API documentation, making sure to use your contract address from step 1 for the receiverAddress.
          * From a different contract
            - As with transmitting a transaction from an EOA, make sure the receiverAddress matches your contract address from step 1.
          * From the same contract
            - Utilize address(this) for the receiverAddress parameter in the flash loan method if you wish to use the same contract as in step 1.
          **Note**: Never keep funds permanently on your FlashLoanReceiverBase
          contract as they could be exposed to a ['griefing'
          attack](https://ethereum.stackexchange.com/a/92457/19365), where the
          stored funds are used by an attacker.


          #### Final Step: Completing the flash loan

          If you used flashLoanSimple() or interestRateMode=0 in flashLoan() for
          any of the assets in the modes parameter, you will need to repay the
          flash loaned amounts once you have completed your logic with the flash
          loaned assets (in your executeOperation() method).

          * Repaying a flash loaned asset
            - Check that your contract includes the appropriate amount + premium to repay the borrowed asset. This can be calculated by adding the relevant entries in the amounts and premiums array given to the executeOperation() function. \
            - You are not required to return the owing sum to the Pool. The cash will be automatically withdrawn at the end of your operation.
          * Getting into debt (i.e. not immediately paying back)
            - If you used mode=1 or mode=2 for any of the assets in the modes parameter, the address put in for onBehalfOf will incur the obligation if the onBehalfOf address previously authorised the msg.sender to incur debts on their behalf.
            - This means that you can have some assets that are promptly paid back while others incur debt.
    questions:
      - uuid: 7e267f35-7837-4aa9-9081-9ec8ab708a79
        type: SingleChoice
        content: Select the correct option.
        hint: NoHint
        explanation: >-
          Since cryptocurrency is highly volatile, borrowing in Aave demands
          overcollateralization.
        answerKeys:
          - B
        subTopics:
          - aave-smart-contracts-intro
        difficultyLevel: Low
        choices:
          - content: Borrowing in Aave is undercollateralized
            key: A
          - content: Borrowing in Aave is overcollateralized
            key: B
          - content: Depositing in Aave is overcollateralized
            key: C
          - content: None of the above
            key: D
      - uuid: 98442878-4460-4bdd-88f0-1b2a9bce6dfd
        type: SingleChoice
        content: When does a liquidation event occur?
        hint: NoHint
        explanation: >-
          A liquidation event happens when the price of the collateral drops
          below the liquidation threshold.
        answerKeys:
          - C
        subTopics:
          - aave-smart-contracts-intro
        difficultyLevel: Low
        choices:
          - content: >-
              When the price of the collateral rises above the liquidation
              threshold
            key: A
          - content: >-
              When the price of the collateral is equal to the liquidation
              threshold
            key: B
          - content: >-
              When the price of the collateral drops below the liquidation
              threshold
            key: C
          - content: When the price of the collateral doubles the liquidation threshold
            key: D
      - uuid: db260d6f-9851-459f-9170-b59d73460723
        type: SingleChoice
        content: What is Liquidation Bonus?
        hint: NoHint
        explanation: >-
          Liquidation bonus is the bonus paid to liquidators to encourage the
          purchase of specified collateral with a health factor less than one
        answerKeys:
          - D
        subTopics:
          - terminology
        difficultyLevel: Low
        choices:
          - content: >-
              The bonus paid to liquidators to encourage the purchase of
              specified collateral with a health factor more than one
            key: A
          - content: >-
              The bonus paid to liquidators to encourage the purchase of
              specified collateral with a health factor equal to one
            key: B
          - content: >-
              The bonus paid to liquidators to encourage the purchase of
              specified collateral with a health factor more than or equal to
              one
            key: C
          - content: >-
              The bonus paid to liquidators to encourage the purchase of
              specified collateral with a health factor less than one
            key: D
      - uuid: b8d4ad4a-c761-47f2-ad99-2904f842fbd2
        type: SingleChoice
        content: >-
          What is the maximum borrowing capacity of a particular collateral
          known as?
        hint: NoHint
        explanation: >-
          Loan To Value is the maximum borrowing capacity of a particular
          collateral. If a collateral has a Loan to Value of 75%, the user will
          be allowed to borrow 0.75 ETH of primary currency for every 1 ETH of
          collateral. The Loan To Value is represented in percentage points and
          is set per collateral.
        answerKeys:
          - C
        subTopics:
          - terminology
        difficultyLevel: Low
        choices:
          - content: Liquidation Threshold
            key: A
          - content: Liquidity Index
            key: B
          - content: Loan To Value
            key: C
          - content: Liquidation Bonus
            key: D
      - uuid: 619a9931-752e-4a4e-b88b-7700603d1c51
        type: SingleChoice
        content: What do you understand by liquidation threshold?
        hint: NoHint
        explanation: >-
          Liquidation Threshold is the amount of a borrow position that must be
          liquidated because it is undercollateralized. When a collateral has an
          80% liquidation threshold, it signifies that the loan will be
          liquidated when the debt value equals 80% of the collateral value. The
          liquidation threshold is defined in percentage points and is specified
          per collateral.
        answerKeys:
          - A
        subTopics:
          - terminology
        difficultyLevel: Low
        choices:
          - content: >-
              The amount of a borrow position that must be liquidated because it
              is undercollateralized
            key: A
          - content: >-
              The ratio of total collateral multiplied by the liquidation
              threshold to borrowed principal
            key: B
          - content: >-
              The amount of a borrow position that must be liquidated because it
              is overcollateralized
            key: C
          - content: The maximum borrowing capacity of a particular collateral
            key: D
      - uuid: 3326b2c9-6f6e-4f38-b724-2f5a3d758d1f
        type: SingleChoice
        content: How many versions of the AAVE protocol have been released?
        hint: NoHint
        explanation: Aave has released three versions (v1, v2 and v3) as of now.
        answerKeys:
          - C
        subTopics:
          - versions
        difficultyLevel: Low
        choices:
          - content: One
            key: A
          - content: Two
            key: B
          - content: Three
            key: C
          - content: Zero
            key: D
      - uuid: fb570d02-88db-425f-8d8f-3f4f8a38b9ce
        type: SingleChoice
        content: What is Health Factor?
        hint: NoHint
        explanation: >-
          Health factor is the ratio of total collateral multiplied by the
          liquidation threshold to borrowed principal. When the Health Factor
          falls below one, the loan is considered undercollateralized and can be
          liquidated.
        answerKeys:
          - A
        subTopics:
          - terminology
        difficultyLevel: Low
        choices:
          - content: >-
              The ratio of total collateral multiplied by the liquidation
              threshold to borrowed principal
            key: A
          - content: >-
              The ratio of total collateral multiplied by the borrowed principal
              to liquidation threshold
            key: B
          - content: The ratio of total collateral to borrowed principal
            key: C
          - content: The ratio of total collateral to liquidation threshold
            key: D
      - uuid: 2613cb0b-1247-4471-b174-f5ff2f7fbc47
        type: SingleChoice
        content: Which contract has been decommissioned in Aave v2?
        hint: NoHint
        explanation: >-
          LendingPoolCore has been decommissioned. Only LendingPool is used,
          which simplifies integrations and Aave v2 development.
        answerKeys:
          - C
        subTopics:
          - versions
        difficultyLevel: Low
        choices:
          - content: LendingPoolAddressesProvider
            key: A
          - content: LendingPool
            key: B
          - content: LendingPoolCore
            key: C
          - content: LendingPoolAddressesProviderRegistry
            key: D
      - uuid: 5d69612e-6241-4bfc-a247-b7ef12f9e9c0
        type: MultipleChoice
        content: Pick the correct option(s).
        hint: NoHint
        explanation: >-
          Flash loans can now be executed in batches, which means that many
          flash loans with varied parameters can be performed in the same call.
          This opens the door to strong new use cases, such as repaying numerous
          assets and positions with a single flash loan transaction. You can now
          do a combination of 'conventional' flash loans that are paid back
          instantly and flash loans that incur debt (i.e. the flash loan is not
          paid back immediately).
        answerKeys:
          - A
          - C
        subTopics:
          - versions
        difficultyLevel: Low
        choices:
          - content: >-
              Many flash loans with varied parameters can now be performed in
              the same call
            key: A
          - content: >-
              Many flash loans with varied parameters can not be performed in
              the same call
            key: B
          - content: >-
              You can now do a combination of 'conventional' flash loans that
              are paid back instantly and flash loans that incur debt
            key: C
          - content: >-
              You can not do a combination of 'conventional' flash loans that
              are paid back instantly and flash loans that incur debt
            key: D
      - uuid: 1e7412d2-0f89-4fd1-b742-5ea072b8efb6
        type: SingleChoice
        content: Which contract is the main entry point into the Aave Protocol?
        hint: NoHint
        explanation: >-
          LendingPool is the main entry point into the Aave Protocol. Most
          interactions with Aave will happen via the LendingPool.
        answerKeys:
          - B
        subTopics:
          - overview
        difficultyLevel: Low
        choices:
          - content: LendingPoolAddressesProvider
            key: A
          - content: LendingPool
            key: B
          - content: LendingPoolCore
            key: C
          - content: LendingPoolAddressesProviderRegistry
            key: D
      - uuid: f27e3567-22d4-441a-9b29-5e306dcff815
        type: SingleChoice
        content: >-
          Which contract can be used to obtain the most recent contract
          addresses?
        hint: NoHint
        explanation: >-
          LendingPoolAddressesProvideris the protocol's primary addresses
          register for specific marketplaces. The most recent contract addresses
          should be obtained from this contract by making the necessary calls.
        answerKeys:
          - A
        subTopics:
          - overview
        difficultyLevel: Low
        choices:
          - content: LendingPoolAddressesProvider
            key: A
          - content: LendingPool
            key: B
          - content: LendingPoolCore
            key: C
          - content: LendingPoolAddressesProviderRegistry
            key: D
      - uuid: 09ef1435-b99e-457d-bb95-b8f493d6b14e
        type: SingleChoice
        content: >-
          Which of the following methods is not included in the LendingPool
          contract?
        hint: NoHint
        explanation: >-
          Most interactions with Aave will happen via the LendingPool, including
          deposit(), borrow(), repay(), swapBorrowRateMode(),
          setUserUseReserveAsCollateral(), withdraw(), flashloan(),
          liquidationCall().
        answerKeys:
          - D
        subTopics:
          - overview
        difficultyLevel: Low
        choices:
          - content: deposit()
            key: A
          - content: borrow()
            key: B
          - content: withdraw()
            key: C
          - content: scaledTotalSupply()
            key: D
      - uuid: 7c7535a8-942c-4d6f-a49c-ecbbb587f175
        type: SingleChoice
        content: >-
          Despite all of the new features added in v3, the overall gas cost of
          all functions fell. By what percentage did the gas cost fall?
        hint: NoHint
        explanation: explanation
        answerKeys:
          - B
        subTopics:
          - versions
        difficultyLevel: Low
        choices:
          - content: The overall gas cost of all functions fell by about 50%
            key: A
          - content: The overall gas cost of all functions fell by about 25%
            key: B
          - content: The overall gas cost of all functions fell by about 2.5%
            key: C
          - content: The overall gas cost of all functions fell by about 5%
            key: D
      - uuid: aadd93bd-8e38-4969-9f4d-ecbc5f2f3802
        type: SingleChoice
        content: Can any individual lend and borrow simultaneously via Aave?
        hint: NoHint
        explanation: >-
          An individual can lend and borrow simultaneously via Aave. The
          participants lending the tokens get interest on their loan and the
          participants borrowing the tokens pay interest.
        answerKeys:
          - A
        subTopics:
          - aave-smart-contracts-intro
        difficultyLevel: Low
        choices:
          - content: Yes, any individual lend and borrow simultaneously via Aave
            key: A
          - content: No, any individual can not lend and borrow simultaneously via Aave
            key: B
          - content: >-
              Only possible when the price of the collateral drops below the
              liquidation threshold
            key: C
          - content: >-
              Only possible when the price of the collateral rises above the
              liquidation threshold
            key: D
      - uuid: 13dc4af8-4bac-44d8-8977-26a93135de9c
        type: SingleChoice
        content: What happens when the Health Factor falls below one?
        hint: NoHint
        explanation: >-
          Health factor is the ratio of total collateral multiplied by the
          liquidation threshold to borrowed principal. When the Health Factor
          falls below one, the loan is considered undercollateralized and can be
          liquidated.
        answerKeys:
          - C
        subTopics:
          - terminology
        difficultyLevel: Low
        choices:
          - content: The loan is considered overcollateralized and can be liquidated.
            key: A
          - content: >-
              The loan is considered undercollateralized and can not be
              liquidated.
            key: B
          - content: The loan is considered undercollateralized and can be liquidated.
            key: C
          - content: >-
              The loan is considered overcollateralized and can not be
              liquidated.
            key: D
      - uuid: 2100e607-e07e-4c5b-a2b6-44301d59363e
        type: SingleChoice
        content: >-
          What is the ratio in which aTokens can be redeemed for the underlying
          token?
        hint: NoHint
        explanation: aTokens can be redeemed for the underlying token in a 1:1 ratio
        answerKeys:
          - C
        subTopics:
          - functions-1
        difficultyLevel: Low
        choices:
          - content: aTokens can be redeemed for the underlying token in a 1:10 ratio
            key: A
          - content: aTokens can be redeemed for the underlying token in a 11:1 ratio
            key: B
          - content: aTokens can be redeemed for the underlying token in a 1:1 ratio
            key: C
          - content: aTokens can be redeemed for the underlying token in a 1:11 ratio
            key: D
      - uuid: d97848fc-cec7-4ce4-b39f-694fc565ca65
        type: MultipleChoice
        content: Pick the correct option(s).
        hint: NoHint
        explanation: >-
          Because the protocol does not employ an EIP-20 wrapper like wETH for
          ETH deposits, the deposit() method's amount parameter must match the
          transaction's msg.value parameter and be included in your deposit()
          call.
        answerKeys:
          - A
          - c
        subTopics:
          - functions-1
        difficultyLevel: Low
        choices:
          - content: AAVE protocol does not employ an EIP-20 wrapper
            key: A
          - content: AAVE protocol employs an EIP-20 wrapper
            key: B
          - content: >-
              The deposit() method's amount parameter must match the
              transaction's msg.value parameter
            key: C
          - content: >-
              The deposit() method's amount parameter may or may not match the
              transaction's msg.value parameter
            key: D
      - uuid: 82214e78-253d-4fbc-bb56-fcd4dd805de8
        type: SingleChoice
        content: Which method allows the user's deposit to be used as collateral?
        hint: NoHint
        explanation: >-
          setUserUseReserveAsCollateral() allows the user's deposit to be used
          as collateral. Users will only be able to disable deposits that are
          not being used as collateral at the time.
        answerKeys:
          - D
        subTopics:
          - functions-1
        difficultyLevel: Low
        choices:
          - content: deposit()
            key: A
          - content: setUserUseDepositAsCollateral()
            key: B
          - content: setUserReserveAsCollateral()
            key: C
          - content: setUserUseReserveAsCollateral()
            key: D
      - uuid: f8891660-96d9-4b5c-94fb-5d9c611815ee
        type: MultipleChoice
        content: >-
          Which of the following statements about the repay() method is/are
          correct?
        hint: NoHint
        explanation: >-
          repay() method is used to repay a borrowed asset in whole or in part.
          The _onBehalfOf parameter can be used to repay a different user's
          debt. When a third-party repays another user's debt on their behalf,
          the third-party address must approve() the LendingPoolCore contract
          (which is separate from the LendingPool contract) with the _amount of
          the underlying ERC20 of the _reserve contract.
        answerKeys:
          - B
          - C
        subTopics:
          - functions-2
        difficultyLevel: Low
        choices:
          - content: A borrowed asset has to be repaid in whole
            key: A
          - content: A borrowed asset can be repaid in whole or in part
            key: B
          - content: A third-party can repay another user's debt on their behalf
            key: C
          - content: A third-party can not repay another user's debt on their behalf
            key: D
      - uuid: 7c65668d-8b7b-4de9-8bd9-33736175bb18
        type: SingleChoice
        content: >-
          Which method changes the borrow rate modes of the msg.sender from
          stable to variable?
        hint: NoHint
        explanation: >-
          swapBorrowRateMode() changes the borrow rate modes of the msg.sender
          from stable to variable. rebalanceStableBorrowRate() rebalances the
          stable rate of _user
        answerKeys:
          - D
        subTopics:
          - functions-2
        difficultyLevel: Low
        choices:
          - content: rebalanceStableBorrowRate()
            key: A
          - content: rebalanceBorrowRateMode()
            key: B
          - content: swapStableBorrowRate()
            key: C
          - content: swapBorrowRateMode()
            key: D
      - uuid: ecad25a7-bbdf-47cf-a062-325e8624ace5
        type: SingleChoice
        content: What happens when a liquidation is completed successfully?
        hint: NoHint
        explanation: >-
          When the liquidation is completed successfully, the position's health
          factor is enhanced, bringing it above 1. It does not affect the close
          factor.
        answerKeys:
          - A
        subTopics:
          - functions-2
        difficultyLevel: Low
        choices:
          - content: The position's health factor is enhanced, bringing it above 1
            key: A
          - content: The position's health factor is diminished, bringing it below 1
            key: B
          - content: The close factor is enhanced, bringing it above 1
            key: C
          - content: The close factor is diminished, bringing it below 1
            key: D
      - uuid: 48ffb9d9-108c-41e3-9a05-632b49b71d9b
        type: MultipleChoice
        content: What is the close factor?
        hint: NoHint
        explanation: >-
          A close factor determines how much collateral a liquidator can close.
          The current close factor is 0.5. In other words, liquidators can only
          liquidate up to 50% of the amount owing in a position. This is the
          amount of the liquidation discount.
        answerKeys:
          - C
          - D
        subTopics:
          - functions-2
        difficultyLevel: Low
        choices:
          - content: >-
              The ratio of total collateral multiplied by the liquidation
              threshold to borrowed principal
            key: A
          - content: The maximum borrowing capacity of a particular collateral
            key: B
          - content: Determines how much collateral a liquidator can close
            key: C
          - content: It is the amount of the liquidation discount
            key: D
      - uuid: 26144fd7-a1ae-44c4-b70f-dc6cc578ea87
        type: SingleChoice
        content: >-
          What value of the purchaseAmount parameter can be set to proceed with
          the largest liquidation allowed by the close factor?
        hint: NoHint
        explanation: >-
          purchaseAmount parameter can be set to uint(-1) and the protocol will
          proceed with the largest liquidation allowed by the close factor.
        answerKeys:
          - B
        subTopics:
          - functions-2
        difficultyLevel: Low
        choices:
          - content: uint(1)
            key: A
          - content: uint(-1)
            key: B
          - content: uint(10)
            key: C
          - content: uint(-10)
            key: D
      - uuid: f355a01c-c3d1-41f3-9685-c65d64b16926
        type: MultipleChoice
        content: Select the correct statement(s) about Flash loans.
        hint: NoHint
        explanation: >-
          Flash Loans are special transactions that allow you to borrow an asset
          as long as the borrowed amount (plus a fee) is returned before the
          transaction ends (also called One Block Borrows). These transactions
          do not necessitate the provision of collateral by the user prior to
          the transaction.
        answerKeys:
          - A
          - B
        subTopics:
          - functions-3
        difficultyLevel: Low
        choices:
          - content: Flash loans are also called One Block Borrows
            key: A
          - content: Borrowed amount has to be returned in the same transaction
            key: B
          - content: There is no need to pay fees
            key: C
          - content: User has to provide collateral prior to the transaction
            key: D
      - uuid: c535ee8a-5ac8-47bf-8404-30138aae06f6
        type: SingleChoice
        content: Which of the following is the fee received by LP?
        hint: NoHint
        explanation: >-
          Fee to LP = FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL,
          Fee to Protocol = FLASHLOAN_PREMIUM_TO_PROTOCOL
        answerKeys:
          - C
        subTopics:
          - functions-3
        difficultyLevel: Low
        choices:
          - content: FLASHLOAN_PREMIUM_TO_PROTOCOL
            key: A
          - content: FLASHLOAN_PREMIUM_TOTAL
            key: B
          - content: FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL
            key: C
          - content: FLASHLOAN_PREMIUM_TOTAL + FLASHLOAN_PREMIUM_TO_PROTOCOL
            key: D
    readings:
      - uuid: 7441eb5f-68f3-40de-b12f-80dc17c80b2c
        title: Introduction to AAVE Smart Contracts
        shortTitle: Introduction
        type: YoutubeVideo
        url: https://www.youtube.com/watch?v=AMAMvKc-O2s
        subTopics:
          - aave-smart-contracts-intro
        details: |
          This video enables learners to know about
            * AAVE
            * Main protocol features
            * What's new in v2   
            * Resources
      - uuid: 8b2485fe-7a9b-4dee-9e65-348c1dc7a66c
        title: Introduction to AAVE Smart Contracts
        shortTitle: Introduction
        type: YoutubeVideo
        url: https://www.youtube.com/watch?v=LzaS8IiqnPY
        subTopics:
          - aave-smart-contracts-intro
        details: |
          This video enables learners to know about
            * AAVE v3 features
            * Build on top of AAVE
    summaries:
      - title: Introduction
        shortTitle: Introduction
        key: aave-smart-contracts-intro
        details: >
          * Aave is a decentralized finance protocol that facilitates lending
          and borrowing of cryptocurrency tokens usAave ing diverse algorithms
          and smart contracts without the presence of centralized
          intermediaries. 

          * It is a non-custodial liquidity protocol that allows users to
          participate as depositors or borrowers. Depositors provide liquidity
          to the market to earn a passive income, while borrowers are able to
          borrow in an overcollateralized manner.

          * The participants lending the tokens get interest on their loan and
          the participants borrowing the tokens pay interest. 

          * An individual can lend and borrow simultaneously via Aave.

          * The working mechanism of Aave involves allocating a platform
          specific token, called aTokens to a user's crypto investment. This is
          what lenders get when they deposit their assets into the pool.

          * For instance, a user who deposits Ethereum in Aave will hold aETH on
          Aave. 

          * aToken is based on a particular crypto asset and the interest rate
          each aToken earns is specific to the token deposited, depending on the
          supply and demand for the original coin.


          * Aave has a smart contract based working mechanism wherein the
          interest rates are determined by different algorithms.

          * The depositors lend the funds in the liquidity pools and earn
          interest, similarly borrowers can borrow the funds from the liquidity
          pools. 

          * The interest rate for both borrowers and lenders is decided
          algorithmically:

          * **Interest rate for Borrowers**: The interest rate to be paid by the
          borrowers depends on the cost of money and the amount of funds
          available in the pool at a specific time.The amount of funds present
          in the pool has an inverse relationship with the interest rate. As
          funds are borrowed from the pool, the amount of funds available
          decreases which raises the interest rate. 

          * **Interest rate for Lenders**: The interest rate received by the
          lenders corresponds to the earn rate, with the algorithm safeguarding
          a liquidity reserve to guarantee withdrawals at any time.


          * Since cryptocurrency is highly volatile, borrowing in Aave demands
          overcollateralization. 

          * A liquidation event happens when the price of the collateral drops
          below the liquidation threshold.
      - title: Important Tech Terms
        shortTitle: Tech Terms
        key: terminology
        details: >
          * **APY**: Annual Percentage Yield is the yield/interest after a year,
          including compounding interest. This differs from the Annual
          Percentage Rate (APR), which does not account for compounding effects.


          * **Liquidity Index**: The reserve's interest accumulation during the
          time span since the last updated timestamp.


          * **Loan To Value**: The maximum borrowing capacity of a particular
          collateral. If a collateral has a Loan to Value of 75%, the user will
          be allowed to borrow 0.75 ETH of primary currency for every 1 ETH of
          collateral. The Loan To Value is represented in percentage points and
          is set per collateral.


          * **Liquidation Threshold**: The amount of a borrow position that must
          be liquidated because it is undercollateralized. When a collateral has
          an 80% liquidation threshold, it signifies that the loan will be
          liquidated when the debt value equals 80% of the collateral value. The
          liquidation threshold is defined in percentage points and is specified
          per collateral.


          * **Liquidation Bonus**: The bonus paid to liquidators to encourage
          the purchase of specified collateral with a health factor less than
          one. The Liquidation Bonus is defined in percentage points and is
          determined per collateral.


          * **Health factor**: The ratio of total collateral multiplied by the
          liquidation threshold to borrowed principal. When the Health Factor
          falls below one, the loan is considered undercollateralized and can be
          liquidated.


          * **Stable rate**: A loan with a stable rate behaves like a fixed rate
          loan in the short term, but the rates can be rebalanced in the
          medium/long term in response to rapid market movements.


          * **Reserve** : Reserves are the underlying assets' ERC-20 contracts.
      - title: Released Versions
        shortTitle: Versions
        key: versions
        details: >
          * Aave has released three versions (v1, v2 and v3) as of now and the
          Governance token of Aave is "AAVE". Version 1 or v1 is the base
          version launched in 2017 and then there have been upgrades with
          multiple new features added. 

          * Aave v2 improves on many areas of v1. Some of the changes are:
            - There is no longer a LendingPoolCore contract in Aave v2 that retains all of the protocol's assets. Assets are held directly in the linked aToken contracts, with the LendingPool contract serving as the protocol's "core."
            - Almost all actions in Aave v2 should be executed via the LendingPool contract. This differs from v1, when a redemption/withdrawal of aTokens required a call on the aToken contract.
            - After depositing collateral into the protocol, a user can easily delegate credit to any address by using approveDelegation() on the relevant debt token.
            - Flash loans are possible inside the Aave v2 protocol. Indeed, they are widely utilised within the protocol for position switching and other 'trading'-like functions.
            - Flash loans can now be executed in batches, which means that many flash loans with varied parameters can be performed in the same call. This opens the door to strong new use cases, such as repaying numerous assets and positions with a single flash loan transaction.
            - You can now do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt (i.e. the flash loan is not paid back immediately).
            - AddressesProviders will be numerous in multiple markets. The AddressesProviderRegistry will keep track of all Aave market address providers.
            - LendingPoolCore has been decommissioned. Only LendingPool is used, which simplifies integrations and Aave v2 development.
          * The v3 improved features enable new use cases, sparking a flood of
          innovation from users and developers. Aave V3 generates I mprovements
          in all of the these areas - capital efficiency, security,
          decentralisation, and UX - while simultaneously delivering new
          functions to harness the capabilities of rollups and the developing
          ecosystem of rival L1s.
            - Portal is a new set of core functionalities that can be utilised to enable provided assets to move easily between Aave markets on different networks. On the surface, the feature is fairly simple: the protocol uses the aTokens' unique pegged design to burn aTokens on the source network while minting them on the destination network.
            - Borrowers can use High Efficiency Mode (E-Mode) to get the most borrowing power out of their collateral. Borrowers can use E-Mode to limit their borrowing to only assets in a specific category (e.g., stablecoins).
            - One of the most important areas for improvement is managing the inherent complexities of risk exposure modulation.
            - Repay with aTokens: Allows borrowers to repay with aTokens rather than the underlying asset.
            - Despite all of the new features, the overall gas cost of all functions fell by about 25%.
            - Smart contract re-engineering has considerably reduced code size (leaving more room for future revisions) by up to 100K optimizer runs!
            - All token transfer functions (supply, repay) now support EIP 2612 authorization (this is especially important for L2).
            - Signature on EIP 712 for credit delegation (no need for contracts to request a user transaction anymore).
      - title: Protocol Overview
        shortTitle: Overview
        key: overview
        details: >
          * Below image provides an overview of the protocol.


          ![Architecture](https://github.com/DoDAO-io/dodao-aave-developer-1-course/blob/6bd13f67bbb027bc58280c103f78b0b29d5ad810/images/architechture.png?raw=true)

          `Reference:
          https://docs.aave.com/developers/v/2.0/the-core-protocol/protocol-overview`


          * On Github, the Aave Protocol repository can be found here:
          https://github.com/aave/


          #### Main Contracts

          The main contracts in Aave and their purposes are:

          * LendingPool: The main entry point into the Aave Protocol. Most
          interactions with Aave will happen via the LendingPool, including:
            - deposit()
            - borrow()
            - repay()
            - swapBorrowRateMode()
            - setUserUseReserveAsCollateral()
            - withdraw()
            - flashloan()
            - liquidationCall()
          * LendingPoolAddressesProvider: The protocol's primary addresses
          register for specific marketplaces. The most recent contract addresses
          should be obtained from this contract by making the necessary calls.

          * LendingPoolAddressesProviderRegistry: Contains a list of active
          LendingPoolAddressesProvider addresses, for different markets.

          * aTokens: The yield-producing, tokenized deposits that are used
          throughout the Aave protocol. They implement, with minor
          modifications, the majority of the standard EIP-20/ERC20 token
          methods, as well as Aave-specific methods such as:
            - scaledBalanceOf()
            - getScaledUserBalanceAndSupply()
            - scaledTotalSupply()
            All aTokens also implement EIP-2612, which via the permit() function enables gas-less transfers and single transaction approve + actions.
          * Stable and Variable Debt Tokens: The Aave protocol employs tokenised
          borrow locations throughout. Because debt tokens are non-transferable,
          most common EIP-20/ERC20 techniques are disabled.
      - title: AAVE Functionalities in Details - I
        shortTitle: Functions - I
        key: functions-1
        details: >
          * The LendingPool contract is the protocol's principal contract. It
          exposes all user-oriented operations that may be performed with the
          Solidity or web3 libraries. The source code is available
          [here](https://github.com/aave/aave-protocol/blob/master/contracts/lendingpool/LendingPool.sol).


          #### Deposit/Lending

          * Lenders share the interest payments made by borrowers based on the
          utilization rate multiplied by the average borrowing rate. The yield
          for depositors increases as reserve utilization increases.

          * Lenders are also entitled to a portion of the Flash Loan fees, equal
          to 0.09% of the Flash Loan volume.

          * There is no minimum or maximum deposit amount; you may deposit any
          amount you choose.


          #### Methods

          #### deposit()

          **function deposit( address _reserve, uint256 _amount, uint16
          _referralCode)**

          * Deposits a certain _amount of an asset specified by the _reserve
          parameter.

          * In exchange, the caller receives a specific number of aTokens.
          aTokens can be redeemed for the underlying token in a 1:1 ratio.

          * When depositing an ERC-20 token, the LendingPoolCore contract (not
          the LendingPool contract) must have the required allowance of _amount
          for the underlying ERC20 of the _reserve asset via approve().


          **ETH deposits**

          * Because the protocol does not employ an EIP-20 wrapper like wETH for
          ETH deposits, the deposit() method's amount parameter must match the
          transaction's msg.value parameter and be included in your deposit()
          call.

          * E.g: lendingPool.deposit{ value: msg.value }(reserve, msg.value,
          referralCode)

          * Because ETH is utilised directly in the protocol (rather than an
          abstraction like WETH), we use a dummy address to represent it:
          0xEeeeeEeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee


          **ERC20 deposits**

          * The _reserve parameter corresponds to the underlying asset's ERC20
          contract address.

          * Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L753


          * The deposit() flow within the protocol is available
          [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH4HvCIm09jkjFv%2Flending%20pool%20deposit.png?alt=media&token=c92f8256-9d73-41a1-9e96-a3d807425d08)
           
          #### setUserUseReserveAsCollateral()

          **function setUserUseReserveAsCollateral(address _reserve, bool
          _useAsCollateral)**

          * Allow the user's deposit to be used as collateral. Users will only
          be able to disable deposits that are not being used as collateral at
          the time.

          * Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L341 


          **Stable vs Variable Interest Rate**

          * In the short-term, stable rates function as a fixed rate, but they
          can be rebalanced in the long run in reaction to alterations in the
          market environment. 

          * Depending on supply and demand in Aave, the variable rate can
          change.

          * The stable rate is the better choice for forecasting how much
          interest you will have to pay because, as its name suggests, it will
          remain fairly stable. The variable rate changes over time and,
          depending on market conditions, could be the optimal rate.
      - title: AAVE Functionalities in Details - II
        shortTitle: Functions - II
        key: functions-2
        details: >
          #### Borrow

          * You must deposit any asset to be used as collateral before
          borrowing.The amount you can borrow depends on the value you have
          deposited and the readily available liquidity.For instance, if there
          isn't enough liquidity or if your health factor (minimum threshold of
          the collateral = 1, below this value, liquidation of your collateral
          is triggered) prevents it, you can’t borrow an asset. The loan is
          repaid with the same asset that you borrowed.

          * For instance, if you borrow 1 ETH, you'll need to pay back 1 ETH
          plus interest.

          * In the updated Version 2 of the Aave Protocol, you can also use your
          collateral to make payments. You can borrow any of the stablecoins
          like USDC, DAI, USDT, etc. if you want to repay the loan based on the
          price of the USD.


          #### Methods

          #### borrow()

          **function borrow(address _reserve, uint256 _amount, uint256
          _interestRateMode, uint16 _referralCode)** 

          * Transfers a certain amount of the asset identified by the _reserve
          parameter to the msg.sender, provided the caller has deposited enough
          collateral to fund the borrow in advance.

          * Every loan can be opened in either a fixed or variable rate mode.
          Borrows have an indefinite term and no payback date. In the event of
          market swings, a borrow position is liquidated if the collateral price
          falls below a specific threshold. Please read the White Paper to learn
          more about the stable rate economy.

          * Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L219 


          * The borrow() flow within the protocol is available
          [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH3GOEvYvbizwHC%2Flending%20pool%20borrow.png?alt=media&token=2031b536-733e-4a8a-866c-23c86706e641)


          #### repay()

          **function repay( address _reserve, uint256 _amount, address payable
          _onBehalfOf)**

          * Repay a borrowed asset in whole or in part. The _onBehalfOf
          parameter can be used to repay a different user's debt.

          * When a third-party repays another user's debt on their behalf, the
          third-party address must approve() the LendingPoolCore contract (which
          is separate from the LendingPool contract) with the _amount of the
          underlying ERC20 of the _reserve contract.

          * Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L249 


          * The repay() flow within the protocol is available
          [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH9NighH7i_73lI%2Flending%20pool%20repay.png?alt=media&token=cb6e102e-222b-412a-92f0-763ae34e7cce) 
           
          #### swapBorrowRateMode()

          **function swapBorrowRateMode(address _reserve)**

          * Changes the borrow rate modes of the msg.sender from stable to
          variable.

          * Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L326 


          #### rebalanceStableBorrowRate()

          **function rebalanceStableBorrowRate(address _reserve, address
          _user)**

          * Rebalances the stable rate of _user

          * Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L336 


          * The rebalance flow for stable rates in the protocol is available
          [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH7rY4WFE5jRwrB%2Flending%20pool%20rebalancing.png?alt=media&token=8a442d62-6087-4adf-b27b-163478547f79)  


          #### liquidationCall()

          **function liquidationCall(address _collateral, address _reserve,
          address _user, uint256 _purchaseAmount, bool _receiveaToken)**

          * Positions with a health factor less than one should be liquidated.

          * When a position's health factor falls below one, liquidators repay
          part or all of the outstanding borrowed amount on behalf of the
          borrower in exchange for a discounted quantity of collateral
          (sometimes known as a liquidation "bonus"). 

          * Liquidators have the option of receiving an equal quantity of
          collateral aTokens or the underlying asset directly. 

          * When the liquidation is completed successfully, the position's
          health factor is enhanced, bringing it above 1.

          * A close factor determines how much collateral a liquidator can
          close. The current close factor is 0.5. In other words, liquidators
          can only liquidate up to 50% of the amount owing in a position. This
          is the amount of the liquidation discount.

          * Liquidators must approve() the LendingPoolCore contract (which is
          distinct from the LendingPool contract) in order to use the underlying
          ERC20 of the _reserve asset for the liquidation.

          * **NOTE**: In most cases, profitable liquidators will choose to
          liquidate as much of the _user position as possible.

          * purchaseAmount parameter can be set to uint(-1) and the protocol
          will proceed with the largest liquidation allowed by the close factor.

          * For ETH liquidations, the transaction's msg.value should be
          identical to the _purchaseAmount parameter.

          * To determine a user's health factor, use getUserAccountData().

          * Code:
          https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L360 


          * The liquidation flow in the protocol is available
          [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH6dX0q9LDXBn9X%2Flending%20pool%20liquidation.png?alt=media&token=6701e381-1fd1-42ce-919b-39da57434c57)
      - title: AAVE Functionalities in Details - III
        shortTitle: Functions - III
        key: functions-3
        details: >
          * Flash Loans are special transactions that allow you to borrow an
          asset as long as the borrowed amount (plus a fee) is returned before
          the transaction ends (also called One Block Borrows). 

          * These transactions do not necessitate the provision of collateral by
          the user prior to the transaction.

          * To use this feature, you must have a solid understanding of EVM,
          programming, and smart contracts. To do a Flash Loan, you must first
          create a contract requesting a Flash Loan. The contract must follow
          the instructions and repay the loan plus interest and fees in the same
          transaction.


          * Aave v3 provides two flash loan options:
            - **flashLoan**: Allows the borrower to obtain liquidity from various reserves in a single flashLoan transaction. In this instance, the borrower has the option of opening a stable or variable rate debt position backed by supplied collateral or credit delegation.
            - **NOTE**: For qualified flashBorrowers, the loan charge is waived (managed by ACLManager)
            - **flashLoanSimple**: Allows the borrower to access a single reserve of liquidity for the transaction. In this situation, the flash loan fee is not waived, and the borrower is not permitted to open any debt positions at the conclusion of the transaction. For individuals attempting to take advantage of a simple flash loan with a single reserve asset, this strategy is gas efficient.

          #### Flow of Execution

          * A helpful mental model to consider when creating your solution for
          developers:
            - Your contract contacts the Pool contract and requests a Flash Loan for a specific amount(s) of reserve(s) using flashLoanSimple() or flashLoan() ().
            - The Pool sends the requested amounts of reserves to your contract after some sanity checks, then executes executeOperation() on the receiver contract.
            - Your contract now does any arbitrary operation in its code while holding the flash borrowed amount(s).
            - When you finish your code for a flashLoanSimple, you approve Pool for the flash loaned amount + charge.
            - If you are executing flashLoan, then all reserves must be granted for flash borrowed amount + fee or adequate collateral or credit delegation must be provided to start debt position, based on the interestRateMode passed for the asset.
            - If the amount owed is not available (due to a lack of balance or authorisation, or insufficient debt collateral), the transaction is reverted.
            - All of the preceding occurs in a single transaction (hence in a single ethereum block).

          #### Flash Loan Applications

          * Aave Flash Loans are already used for the liquidity swap
          functionality in Aave V3. Other real-world instances include:
          arbitrage between assets without requiring the main amount to be
          present.

          * Liquidating borrow positions without having to repay the debt of the
          positions and paying off flashLoan amount + charge with discounted
          collateral claimed.


          #### Fee for a Flash loan

          * The flash loan charge is set to 0.09% at deployment and can be
          changed via Governance Vote. To obtain the current value, use
          FLASHLOAN PREMIUM TOTAL.

          * The LPs (liquidity providers) and the protocol treasury can split
          the flashloan charge. The FLASHLOAN PREMIUM TOTAL variable represents
          the total charge paid by borrowers, which includes:

          * Fee to LP: FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL

          * Fee to Protocol: FLASHLOAN_PREMIUM_TO_PROTOCOL

          * At initialization, FLASHLOAN_PREMIUM_TO_PROTOCOL is 0.


          #### First step: Setting Up

          * By implementing the relevant executeOperation() function, your
          contract that receives the amounts from flash loans must comply with
          the IFlashLoanSimpleReceiver.sol or IFlashLoanReceiver.sol interface.

          * Additionally, keep in mind that since the owing sums will be
          deducted from your contract, your contract must let the Pool to deduct
          those monies in order to repay the flash loan amount plus premiums.


          #### Second Step: Calling flashLoan() or flashLoanSimple()

          * To invoke either of the Pool's two flash lending methods, we must
          provide the necessary parameters. There are three possibilities.
            - From an EOA ('normal' Ethereum account)
              - To use an EOA, send a transaction to the appropriate Pool and use the flashLoan() or flashLoanSimple() functions. For parameter information, see the Pool API documentation, making sure to use your contract address from step 1 for the receiverAddress.
            - From a different contract
              - As with transmitting a transaction from an EOA, make sure the receiverAddress matches your contract address from step 1.
            - From the same contract
              - Utilize address(this) for the receiverAddress parameter in the flash loan method if you wish to use the same contract as in step 1.
          * **Note**: Never keep funds permanently on your FlashLoanReceiverBase
          contract as they could be exposed to a ['griefing'
          attack](https://ethereum.stackexchange.com/a/92457/19365), where the
          stored funds are used by an attacker.


          #### Final Step: Completing the flash loan

          * If you used flashLoanSimple() or interestRateMode=0 in flashLoan()
          for any of the assets in the modes parameter, you will need to repay
          the flash loaned amounts once you have completed your logic with the
          flash loaned assets (in your executeOperation() method).
            - Repaying a flash loaned asset
              - Check that your contract includes the appropriate amount + premium to repay the borrowed asset. This can be calculated by adding the relevant entries in the amounts and premiums array given to the executeOperation() function. \
              - You are not required to return the owing sum to the Pool. The cash will be automatically withdrawn at the end of your operation.
            - Getting into debt (i.e. not immediately paying back)
              - If you used mode=1 or mode=2 for any of the assets in the modes parameter, the address put in for onBehalfOf will incur the obligation if the onBehalfOf address previously authorised the msg.sender to incur debts on their behalf.
              - This means that you can have some assets that are promptly paid back while others incur debt.
  - title: Fetch and Show AAVE Data
    key: fetching-aave-data
    details: >
      This chapter taks about how you can fetch real time and time series data
      from AAVE and show it on the UI.
    order: 1
    explanations:
      - title: Introduction
        shortTitle: Introduction
        key: aave-data-intro
        details: >
          AAVE is a DeFi protocol that facilitates the lending and borrowing of
          cryptocurrency tokens using diverse algorithms and smart contracts
          without centralized intermediaries. 

          It is a non-custodial liquidity protocol that allows users to
          participate as lenders or borrowers. Depositors provide liquidity to
          the market to earn a passive income, while borrowers are able to
          borrow in an overcollateralized manner.

          Aave's GraphQL data layer is a great resource for developers, allowing
          developers to access data that may not have been available otherwise.
          This way developers can work with more data and create more advanced
          applications. 

          Just like any decentralized blockchain application, Aave's data can be
          classified into three types: 

          - **Real-time data or current information** - This includes the
          current state and the new events. With real-time data, you can use
          data visualisations that reflect changes as they occur in real-time.
          This means that dashboards are interactive and accurate at any given
          moment.

          - **Historical** - This includes past state and events. With
          historical data, you can get a snapshot of information displayed in a
          chart.


          As discussed above, there are multiple use cases of this data provided
          by Aave and varied applications (including read-only as well as
          read/write applications) can be built on top of it and we can examine
          this data to gain insights on how to update and continue to improve
          the application.


          The focus of this chapter will be to use Aave's data and show it on
          the UI in a couple of use cases. 

          - Creating a pie graph to review the aave treasury in USDT 

          - Implementing a time series graph of how the holdings of different
          pools have changed over time.


          Before moving on to the code, let's have a look at the importance of
          analytics.


          **Importance of Analytics**

          - Make informed decisions

          - Improve efficiency

          - Identify frauds

          - Improve protocol governance

          - Accelerate through uncertainty

          - Tackle bugs and problems

          - Transform raw data into more valuable information


          Aave's data can be queried in the form of REST or GraphQL. Aave uses
          “The Graph” to index its data and anyone can query the subgraphs to
          get access to this information.
      - title: Realtime GraphQL Data
        shortTitle: GraphQL
        key: graphql
        details: >
          #### The Graph and GraphQL

          The Graph is a decentralized protocol for indexing and querying data
          from Ethereum-based blockchains. That is, obtaining specific data from
          the blockchain is a more convenient approach while adhering to the
          web3 ethos and benefiting from decentralization and stability.


          The underlying query language used in The Graph is GraphQL. What is
          the distinction between RESTFUL API calls and GraphQL calls?
          Traditional APIs, on the other hand, require developers to define
          unique endpoints for users that return specified data. If the user
          requires further information, they may need to make repeated API
          calls, potentially hundreds of API calls, to obtain it. As long as the
          developer has established a flexible schema, The Graph (which uses
          GraphQL) just requires one call to a subgraph.

          See this [GraphQL
          primer](https://medium.com/graphprotocol/graphql-will-power-the-decentralized-web-d7443a69c69a)
          for additional information on The Graph and the underlying GraphQL.


          #### Source of Aave Subgraphs

          To view the source of the subgraphs, see our [Github
          repo](https://github.com/aave/protocol-v2-subgraph).


          Production Network:
          [Polygon](https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-polygon)


          #### How to Make Use of the Playground


          - If you use your browser to navigate to the above playground links,
          you will be directed to The Graph's playground, where you can simply
          write and test GraphQL queries.

          - Select the purple play button to run your query.

          - In the middle column, the query results will be returned.

          - Use the 'Schema' column on the right to see what data is available,
          which may be investigated to discover the underlying data.

          - You can also type in the left column and use the auto-complete
          feature to identify the appropriate query/types.


          #### Points to keep in mind

          - All address values (for example, when used for id) must be in
          lowercase.

          - In lowercase, the ID of reserves is the asset's address and the
          address of the market's LendingPoolAddressProvider.

          - When utilizing the raw endpoints, the numeric number queried will be
          returned in either wei units (i.e. 10^18), the decimals of the asset
          itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).

          - By default, each 'page' of results returns 100 entries. This is
          expandable to a maximum of 1000 entries per page.

          - To list the following 1000 entries, for example, put something like:
          (skip:1000, first: 1000) to your query's arguments.

          - This is also true for nested entries, such as arrays.


          This Graph endpoint contains only static data. To obtain a user's most
          recent balance (including interest earned up to that moment), you must
          either compute it yourself or make a balanceOf() call to the aToken
          contract.


          | Return Data Type           | Subgraph
          Address                                                       |

          | -------------------------- |
          ----------------------------------------------------------------------
          | 

          | Mainnet                    |
          https://thegraph.com/explorer/subgraph/aave/aave-v2-matic             
          |

          | Görli (Goerli) Testnet     |
          https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-goerli  
          |


          Goerli is an Ethereum test network that allows blockchain development
          testing prior to deployment on the main Ethereum network, Mainnet.
          Görli (Goerli) Testnet is the first proof-of-authority cross-client
          testnet, synching Parity Ethereum, Geth, Nethermind, Hyperledger Besu
          (formerly Pantheon), and EthereumJS. This testnet is a community-based
          project, completely open-source, naturally. It was born in September
          2018 during ETHBerlin and has been growing in contributors ever since.


          #### Using your app to access GraphQL data


          The preferred method is to utilize a client library that can handle
          the 'plumbing' to ensure you have up-to-date data (with caching
          sometimes included). Apollo is used internally, but there are several
          choices depending on your programming language; read the official
          GraphQL page for more information.

          If you are unable to utilize a client library (for example, while
          querying using Postman), you can send a POST request to our subgraph's
          HTTP endpoint with the header: "Content-Type: application/json" and
          the body comprising of your query on one line in quotations. As an
          example:

          ```

          {"query": "{ reserves (where: {usageAsCollateralEnabled: true})  { id
          name price {id} liquidityRate variableBorrowRate stableBorrowRate}}" }

          ```


          #### Examples of Queries


          We'll be using the mainnet Big uints GraphQL endpoints in the queries
          below. These queries can be copied and pasted into the Graph
          playground links.


          ##### Reserve Data

          If we want to receive a list of all the reserves that can be used as
          collateral, as well as the interest rates for each reserve, we can use
          the following query:

          ```

          {
            reserves (where: {
              usageAsCollateralEnabled: true
            }) {
              id
              name
              price {
                id
              }
              liquidityRate
              variableBorrowRate
              stableBorrowRate
            }
          }

          ```

          We would utilise the reserves ERC20 token address to retrieve data for
          a certain reserve. For the Chainlink reserve, for example:

          ```

          {
            reserve(id: "0x514910771af9ca656af840dff83e8264ecf986ca0x24a42fd28c976a61df5d00d0599c34c4f90748c8") { // LINK
              symbol
              price
              aToken {
                id
              }
            }
          }

          ```


          If we wish to retrieve historical interest rate data for a specific
          reserve and paginate through the records, our query may look like
          this:

          ```

          {
            reserve (id: "0x0000000000085d4780b73119b644ae5ecd22b3760x24a42fd28c976a61df5d00d0599c34c4f90748c8") { // TUSD
              id
              paramsHistory(skip:1000, first: 1000) {
                id
                variableBorrowRate
                utilizationRate
                liquidityRate
                timestamp
              }
            }
          }

          ```


          ##### User Data

          When an address communicates with the Aave Protocol, a UserReserve is
          generated, with the user ID equal to the user's address plus the
          reserve's ID (which is the ERC20 token address).

          To obtain information on a certain UserReserve:

          ```

          {
            userReserve(id: "USER_ADDRESS_AND_RESERVE_ADDRESS") {
              reserve {
                id
                symbol
              }
              user {
                id
              }
            }
          }

          ```


          To retrieve all reserves (i.e. positions) held by a specific user
          (notice that the user address must be lower case):

          ```

          {
            userReserves(where: { user: "USER_ADDRESS"}) {
              id
              reserve{
                id
                symbol
              }
              user {
                id
              }
            }
          }

          ```


          ##### Deposit data

          To obtain recent deposits for a certain asset:

          ```

          {
            deposits (orderBy: timestamp, orderDirection: desc, where: { 
              reserve: "0xdac17f958d2ee523a2206206994597c13d831ec70x24a42fd28c976a61df5d00d0599c34c4f90748c8" // USDT
            }) {
              id
              amount
              timestamp
            }
          }

          ```


          ##### Borrow data

          To obtain recent borrows for a certain asset:

          ```

          {
            borrows (orderBy: timestamp, orderDirection: desc, where: { 
              reserve: "0xdac17f958d2ee523a2206206994597c13d831ec70x24a42fd28c976a61df5d00d0599c34c4f90748c8" // USDT
            }) {
              id
              amount
              timestamp
            }
          }

          ```


          ##### Flash loan data

          For instance, consider the following query for analysing the five most
          recent Flash Loans:

          ```

          { 
            flashLoans( 
              first: 5 
              orderBy: timestamp 
              orderDirection: desc 
            ) { 
              id 
              reserve { 
                id 
                name 
                symbol 
              } 
              amount 
              totalFee 
              timestamp 
            } 
          } 

          ```
      - title: >-
          Querying Aave's GraphQL database using React and implementing a Pie
          chart
        shortTitle: React App
        key: react-app
        details: |
          * **Initial Setup**
            First, let's create a React project, you can refer [this](https://create-react-app.dev/docs/getting-started/) documentation.
            ```
            npx create-react-app aave-analytics-sample-app
            ```
            Run npm start to check if the project runs fine.

          * **Integrate ApolloClient**
            Let's integrate the Apollo client library. We can install and setup the client using [this](https://www.apollographql.com/docs/react/get-started/) documentation.
            ```
            npm install @apollo/client graphql
            ```
            We can use the sample code to fetch the data and test our setup.

          * **Initialize the ApolloClient**
            With our dependencies already set up, we can now create an ApolloClient instance.
            Let's start by importing the symbols we require from @apollo/client into index.js:
            ```
            import { ApolloClient, InMemoryCache, ApolloProvider, gql } from '@apollo/client';
            ```
            Next, we'll initialize ApolloClient by handing it a configuration object including the uri and cache fields:
            ```
            const client = new ApolloClient({
              uri: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-goerli',
              cache: new InMemoryCache(),
            });
            ```

          * **Connect the client to React**
            We can connect Apollo Client to React with the ApolloProvider component. Similar to React's Context.Provider, ApolloProvider wraps our React app and places Apollo Client on the context, enabling us to access it from anywhere in our component tree.

            In index.js, let's wrap our React app with an ApolloProvider
            ```
            import React from 'react';
            import * as ReactDOM from 'react-dom/client';
            import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';
            import App from './App';

            const client = new ApolloClient({
              uri: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-goerli',
              cache: new InMemoryCache(),
            });

            const root = ReactDOM.createRoot(document.getElementById('root'));

            root.render(
              <ApolloProvider client={client}>
                <App />
              </ApolloProvider>,
            );
            ```

          * **Fetching data with useQuery**
            After the ApolloProvider is hooked up, we can start requesting data with useQuery. The useQuery hook is a React hook that shares GraphQL data with your UI.
            Switching over to our App.js file, we'll start by replacing our existing file contents with the code snippet below:
            ```
            import { useQuery, gql } from '@apollo/client';

            export default function App() {
            return (
                <div className="App">
                    <h2 className="App-header">AAVE Analytics</h2>
                    <br/>
                    <DisplayGraphs />
                </div>
            );
            }
            ```
            We can define the query we want to execute by wrapping it in the gql template literal:
            ```
            const GET_QUERY = gql`
            {
                reserves {
                    id
                    symbol
                    name
              
                    totalLiquidity
                }
            }
            `;
            ```
            Next, let's define a component named DisplayGraphs that executes our GET_QUERY query with the useQuery hook:
            ```
            function DisplayLocations() {
              const { loading, error, data } = useQuery(GET_QUERY);

              if (loading) return <p>Loading...</p>;
              if (error) return <p>Error :(</p>;

              let names = data.reserves.map(a => a.name);
                let total = data.reserves.map(a => a.totalLiquidity);
                let utilization = data.reserves.map(a => a.utilizationRate);

                total.forEach((element, index) => {
                    total[index] = element % 10^18;
                });
            ….
            }
            ```

          * **Implementing the Pie Chart**
            Now, our aim is to create a pie chart using the data we receive. So now we'll use [react-chartjs-2](https://react-chartjs-2.js.org/).
            ```
            npm install --save chart.js react-chartjs-2
            ```
            Then we will import it in our App.js:
            ```
            import { Pie } from 'react-chartjs-2';
            ```
            Now we need to initialize our code to get a Pie chart:
            ```
            ChartJS.register(ArcElement, Tooltip, Legend);
            ```

          * Finally we will add the code to get our Pie chart:
            ```
            const piedata = {
                    labels: names,
                    datasets: [
                      {
                        label: 'percentage',
                        data: total,
                        backgroundColor: [
                          'rgba(255, 99, 132, 0.2)',
                          'rgba(54, 162, 235, 0.2)',
                          'rgba(255, 206, 86, 0.2)',
                          'rgba(75, 192, 192, 0.2)',
                          'rgba(153, 102, 255, 0.2)',
                          'rgba(255, 159, 64, 0.2)',
                          'rgba(255, 140, 64, 0.2)',
                          'rgba(205, 159, 64, 0.2)',
                        ],
                        borderColor: [
                          'rgba(255, 99, 132, 1)',
                          'rgba(54, 162, 235, 1)',
                          'rgba(255, 206, 86, 1)',
                          'rgba(75, 192, 192, 1)',
                          'rgba(153, 102, 255, 1)',
                          'rgba(255, 159, 64, 1)',
                          'rgba(205, 159, 64, 1)',
                          'rgba(255, 149, 64, 1)',
                        ],
                        borderWidth: 1,
                      },
                    ],
                };

            const optionsPieChart = {
                    responsive: true,
                    plugins: {
                      legend: {
                        position: 'top',
                      },
                      title: {
                        display: true,
                        text: 'Total Liquidity',
                      },
                    },
                };

              return (
                    <div className="Chart-container">
                        <div className="Pie-container">
                            <Pie options={optionsPieChart} data={piedata} />
                        </div>
                    </div>
                );
            ```

            This will give us a Pie chart in our React app.

            You can get the complete code [here](https://github.com/DoDAO-io/aava-analytics-sample-app).
      - title: Historical Rest Data
        shortTitle: Historical Rest Data
        key: historical-rest-data
        details: >
          Now we will use the [Aave Protocol API](https://aave-api-v2.aave.com/)
          to create a time series graph.

          We will use the same react application to create the time series graph
          too, so if you still haven't create a react app by following the
          previous steps.


          Since the the [Aave Protocol API](https://aave-api-v2.aave.com/) is
          for v2 mainnet so now we need to query the Aave v2 mainnet subgraph.


          We need to make the fetch requests from
          https://aave-api-v2.aave.com/#/data/get_data_rates_history to get the
          time series data for any Aave reserve. 

          If you visit the above link, you can see that we require a reserveID
          to fetch the data (there is a sample reserveID already provided in
          case you want to try it out). So to get this reserveID, we will query
          the Aave v2 mainnet subgraph
          (https://thegraph.com/hosted-service/subgraph/aave/protocol-v2 ). We
          have already queried the reserveIDs for ChainLink Token
          (0x514910771af9ca656af840dff83e8264ecf986ca0xb53c1a33016b2dc2ff3653530bff1848a515c8c5)
          and TrueUSD
          (0x0000000000085d4780b73119b644ae5ecd22b3760xb53c1a33016b2dc2ff3653530bff1848a515c8c5)
          which we will be using to plot the graph. 


          If you want to query the reserveID yourself, you can try this:

          ```

          {
            pools {
              reserves {
                id
                name
                symbol
              }
            }
          }

          ```


          This query returns us an array of objects which contains the pools
          with the reserves id, name and symbol.


          Also, in the GET request we need to provide the start date (from) and
          time interval (resolutionInHours) to fetch the data. You can use
          [this](https://www.epochconverter.com/) UNIX timestamp convertor to
          change the date.

          So now you can visit the aave protocol api and playaround with
          different reserveID, from and resolutionInHours.


          Now, let's visit our App.js and add some changes to code to get our
          desired graph.


          * Let's add some import statements as we need to use Line Chart this
          time to represent the time series data. So you can update your import
          statements to the following:
            ```
            import React, {useEffect, useState} from 'react';
            import { useQuery, gql } from '@apollo/client';
            import { Chart as ChartJS, ArcElement, Tooltip, Legend, CategoryScale, LinearScale, PointElement, LineElement, Title, } from 'chart.js';

            import { Pie, Line } from 'react-chartjs-2';
            import './App.css';

            ChartJS.register(ArcElement, 
                CategoryScale,
                LinearScale,
                PointElement,
                LineElement,
                Title,
                Tooltip,
                Legend
            );
            ```

          * Now, we need to fetch the get requests so for that we will use the
          useEffect hook from React and store the data using useState hook. So
          add the following code to your DisplayGraphs functions:
            ```
            const [linedata1, setLinedata1] = useState([]);
                const [linedata2, setLinedata2] = useState([]);

                useEffect(() => {
                    Promise.all([
                        fetch('https://aave-api-v2.aave.com/data/rates-history?reserveId=0x514910771af9ca656af840dff83e8264ecf986ca0xb53c1a33016b2dc2ff3653530bff1848a515c8c5&from=1667952000&resolutionInHours=6'),
                        fetch('https://aave-api-v2.aave.com/data/rates-history?reserveId=0x0000000000085d4780b73119b644ae5ecd22b3760xb53c1a33016b2dc2ff3653530bff1848a515c8c5&from=1667952000&resolutionInHours=6'),
                    ])
                    .then(([resData1, resData2]) => 
                        Promise.all([resData1.json(), resData2.json()])
                    )
                    .then(([data1, data2]) => {
                        console.log(data1, data2);
                        setLinedata1(data1);
                        setLinedata2(data2);
                    })
                    .catch(([err1, err2]) => {
                        console.log(err1.message, err2.message);
                    });
                }, []);
            ```

            The Get request also returns some unwanted data and the timestamp is in a format which we don't like much, so let's update it:
            ```
            let timestamps = linedata1.map(a => (a.x.year + '/' + a.x.month + '/' + a.x.date + ' ' + a.x.hours + ' hours'));
                let utilization1 = linedata1.map(a => a.utilizationRate_avg);
                let utilization2 = linedata2.map(a => a.utilizationRate_avg);

                timestamps.forEach((element, index) => {
                    timestamps[index] = element.toString();
                });
            ```
          * Now, let's create the Line chart using the following code:
            ```
            const optionsLineChart = {
                    responsive: true,
                    plugins: {
                      legend: {
                        position: 'top',
                      },
                      title: {
                        display: true,
                        text: 'Avg Utilization Rate',
                      },
                    },
                };
                  
            const linedata = {
                labels: timestamps,
                datasets: [
                  {
                    label: 'ChainLink Token',
                    data: utilization1,
                    borderColor: 'rgb(255, 99, 132)',
                    backgroundColor: 'rgba(255, 99, 132, 0.5)',
                  },
                  {
                    label: 'TrueUSD',
                    data: utilization2,
                    borderColor: 'rgb(53, 162, 235)',
                    backgroundColor: 'rgba(53, 162, 235, 0.5)',
                  },
                ],
            };

            return (
                <div className="Chart-container">
                    <div className="Pie-container">
                        <Pie options={optionsPieChart} data={piedata} />
                    </div>
                    <div className="Line-container">
                        <Line options={optionsLineChart} data={linedata} />
                    </div> 
                </div>
            );
            ```

          This will provide us with the following time series graph:


          You can get the complete code
          [here](https://github.com/DoDAO-io/aava-analytics-sample-app). 
    questions:
      - uuid: eca9d545-0c8a-42f8-8d45-5dfd675a4187
        type: MultipleChoice
        content: Which of the following points about AAVE is/are correct?
        hint: NoHint
        explanation: >-
          AAVE is a DeFi protocol that facilitates the lending and borrowing of
          cryptocurrency tokens using diverse algorithms and smart contracts
          without centralized intermediaries. It is a non-custodial liquidity
          protocol that allows users to participate as lenders or borrowers.
        answerKeys:
          - A
          - C
        subTopics:
          - aave-data-intro
        difficultyLevel: Low
        choices:
          - content: AAVE is a decentralized finance protocol
            key: A
          - content: AAVE is a centralized finance protocol
            key: B
          - content: AAVE is a non-custodial liquidity protocol
            key: C
          - content: AAVE is a custodial liquidity protocol
            key: D
      - uuid: 7e090787-7925-4eda-8acd-fb90dce8582e
        type: MultipleChoice
        content: Select the correct statement(s).
        hint: NoHint
        explanation: >-
          RESTFUL APIs require developers to define unique endpoints for users
          that return specified data. If the user requires further information,
          they may need to make repeated API calls, potentially hundreds of API
          calls, to obtain it. As long as the developer has established a
          flexible schema, The Graph (which uses GraphQL) just requires one call
          to a subgraph.
        answerKeys:
          - A
          - B
          - D
        subTopics:
          - graphql
        difficultyLevel: Low
        choices:
          - content: >-
              RESTFUL APIs require developers to define unique endpoints for
              users that return specified data.
            key: A
          - content: >-
              If the user requires further information, they may need to make
              repeated API calls
            key: B
          - content: >-
              The Graph requires developers to define unique endpoints for users
              that return specified data.
            key: C
          - content: The Graph just requires one call to a subgraph.
            key: D
      - uuid: e2fb2ae0-dc82-454b-988e-ce59d450fe4a
        type: SingleChoice
        content: What is The Graph?
        hint: NoHint
        explanation: >-
          The Graph is a decentralized protocol for indexing and querying data
          from Ethereum-based blockchains.
        answerKeys:
          - B
        subTopics:
          - graphql
        difficultyLevel: Low
        choices:
          - content: Centralized protocol for indexing and querying data
            key: A
          - content: Decentralized protocol for indexing and querying data
            key: B
          - content: Decentralized query language
            key: C
          - content: Centralized query language
            key: D
      - uuid: 053c742c-3992-42da-abac-719e4260b878
        type: SingleChoice
        content: What happens when an address communicates with the Aave Protocol?
        hint: NoHint
        explanation: >-
          When an address communicates with the Aave Protocol, a UserReserve is
          generated, with the user ID equal to the user's address plus the
          reserve's ID (which is the ERC20 token address).
        answerKeys:
          - C
        subTopics:
          - graphql
        difficultyLevel: Low
        choices:
          - content: >-
              A UserReserve is generated, with the user ID equal to the user's
              address
            key: A
          - content: >-
              A UserReserve is generated, with the user ID equal to the
              reserve's ID
            key: B
          - content: >-
              A UserReserve is generated, with the user ID equal to the user's
              address plus the reserve's ID
            key: C
          - content: No UserReserve is generated
            key: D
      - uuid: 078a4e4e-71e1-4e20-ad13-603502171e6c
        type: MultipleChoice
        content: Pick the correct statement(s) about the GraphQL queries.
        hint: NoHint
        explanation: >-
          All address values (for example, when used for id) must be in
          lowercase. In lowercase, the ID of reserves is the asset's address and
          the address of the market's LendingPoolAddressProvider. When utilizing
          the raw endpoints, the numeric number queried will be returned in
          either wei units (i.e. 10^18), the decimals of the asset itself (i.e.
          10^6 for USDC), or ray units (i.e. 10^27).
        answerKeys:
          - B
          - D
        subTopics:
          - graphql
        difficultyLevel: Low
        choices:
          - content: >-
              All address values (for example, when used for id) must be in
              uppercase.
            key: A
          - content: >-
              All address values (for example, when used for id) must be in
              lowercase.
            key: B
          - content: >-
              When utilizing the raw endpoints, the numeric number queried will
              be returned in wei units (i.e. 10^18) only.
            key: C
          - content: >-
              When utilizing the raw endpoints, the numeric number queried will
              be returned in either wei units (i.e. 10^18), the decimals of the
              asset itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).
            key: D
      - uuid: e950c0e1-a368-471f-8671-cc078c0b7571
        type: SingleChoice
        content: What is Goerli?
        hint: NoHint
        explanation: >-
          Goerli is an Ethereum test network that allows blockchain development
          testing prior to deployment on the main Ethereum network, Mainnet.
        answerKeys:
          - B
        subTopics:
          - graphql
        difficultyLevel: Low
        choices:
          - content: Data query language
            key: A
          - content: An Ethereum test network
            key: B
          - content: A decentralized protocol for indexing and querying data
            key: C
          - content: A DeFi protocol
            key: D
    readings:
      - uuid: 7441eb5f-68f3-40de-b12f-80dc17c80b2c
        title: Introduction to AAVE Smart Contracts
        shortTitle: Introduction
        type: YoutubeVideo
        url: https://www.youtube.com/watch?v=AMAMvKc-O2s
        subTopics:
          - aave-smart-contracts-intro
        details: |
          This video enables learners to know about
            * AAVE
            * Main protocol features
            * What's new in v2   
            * Resources
      - uuid: 8b2485fe-7a9b-4dee-9e65-348c1dc7a66c
        title: Introduction to AAVE Smart Contracts
        shortTitle: Introduction
        type: YoutubeVideo
        url: https://www.youtube.com/watch?v=LzaS8IiqnPY
        subTopics:
          - aave-smart-contracts-intro
        details: |
          This video enables learners to know about
            * AAVE v3 features
            * Build on top of AAVE
    summaries:
      - title: Introduction
        shortTitle: Introduction
        key: aave-data-intro
        details: >
          * AAVE is a DeFi protocol that facilitates the lending and borrowing
          of cryptocurrency tokens using diverse algorithms and smart contracts
          without centralized intermediaries. 

          * It is a non-custodial liquidity protocol that allows users to
          participate as lenders or borrowers. Depositors provide liquidity to
          the market to earn a passive income, while borrowers are able to
          borrow in an overcollateralized manner.

          * Aave's GraphQL data layer is a great resource for developers,
          allowing developers to access data that may not have been available
          otherwise. This way developers can work with more data and create more
          advanced applications. 

          * Just like any decentralized blockchain application, Aave's data can
          be classified into three types: 
            - **Real-time data or current information** - This includes the current state and the new events. With real-time data, you can use data visualisations that reflect changes as they occur in real-time. This means that dashboards are interactive and accurate at any given moment.
            - **Historical** - This includes past state and events. With historical data, you can get a snapshot of information displayed in a chart.

          * There are multiple use cases of this data provided by Aave and
          varied applications (including read-only as well as read/write
          applications) can be built on top of it and we can examine this data
          to gain insights on how to update and continue to improve the
          application.


          * The focus of this chapter will be to use Aave's data and show it on
          the UI in a couple of use cases. 
            - Creating a pie graph to review the aave treasury in USDT 
            - Implementing a time series graph of how the holdings of different pools have changed over time.

          * **Importance of Analytics**
            - Make informed decisions
            - Improve efficiency
            - Identify frauds
            - Improve protocol governance
            - Accelerate through uncertainty
            - Tackle bugs and problems
            - Transform raw data into more valuable information

          * Aave's data can be queried in the form of REST or GraphQL. Aave uses
          “The Graph” to index its data and anyone can query the subgraphs to
          get access to this information.
      - title: Realtime GraphQL Data
        shortTitle: GraphQL
        key: graphql
        details: >
          #### The Graph and GraphQL

          * The Graph is a decentralized protocol for indexing and querying data
          from Ethereum-based blockchains. That is, obtaining specific data from
          the blockchain is a more convenient approach while adhering to the
          web3 ethos and benefiting from decentralization and stability.


          * The underlying query language used in The Graph is GraphQL. What is
          the distinction between RESTFUL API calls and GraphQL calls?
          Traditional APIs, on the other hand, require developers to define
          unique endpoints for users that return specified data. If the user
          requires further information, they may need to make repeated API
          calls, potentially hundreds of API calls, to obtain it. As long as the
          developer has established a flexible schema, The Graph (which uses
          GraphQL) just requires one call to a subgraph.

          * See this [GraphQL
          primer](https://medium.com/graphprotocol/graphql-will-power-the-decentralized-web-d7443a69c69a)
          for additional information on The Graph and the underlying GraphQL.


          #### Source of Aave Subgraphs

          * To view the source of the subgraphs, see our [Github
          repo](https://github.com/aave/protocol-v2-subgraph).


          Production Network:
          [Polygon](https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-polygon)


          #### How to Make Use of the Playground


          * If you use your browser to navigate to the above playground links,
          you will be directed to The Graph's playground, where you can simply
          write and test GraphQL queries.

          * Select the purple play button to run your query.

          * In the middle column, the query results will be returned.

          * Use the 'Schema' column on the right to see what data is available,
          which may be investigated to discover the underlying data.

          * You can also type in the left column and use the auto-complete
          feature to identify the appropriate query/types.


          #### Points to keep in mind

          * All address values (for example, when used for id) must be in
          lowercase.

          * In lowercase, the ID of reserves is the asset's address and the
          address of the market's LendingPoolAddressProvider.

          * When utilizing the raw endpoints, the numeric number queried will be
          returned in either wei units (i.e. 10^18), the decimals of the asset
          itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).

          * By default, each 'page' of results returns 100 entries. This is
          expandable to a maximum of 1000 entries per page.

          * To list the following 1000 entries, for example, put something like:
          (skip:1000, first: 1000) to your query's arguments.

          * This is also true for nested entries, such as arrays.


          * This Graph endpoint contains only static data. To obtain a user's
          most recent balance (including interest earned up to that moment), you
          must either compute it yourself or make a balanceOf() call to the
          aToken contract.


          | Return Data Type           | Subgraph
          Address                                                       |

          | -------------------------- |
          ----------------------------------------------------------------------
          | 

          | Mainnet                    |
          https://thegraph.com/explorer/subgraph/aave/aave-v2-matic             
          |

          | Görli (Goerli) Testnet     |
          https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-goerli  
          |


          * Goerli is an Ethereum test network that allows blockchain
          development testing prior to deployment on the main Ethereum network,
          Mainnet. Görli (Goerli) Testnet is the first proof-of-authority
          cross-client testnet, synching Parity Ethereum, Geth, Nethermind,
          Hyperledger Besu (formerly Pantheon), and EthereumJS. This testnet is
          a community-based project, completely open-source, naturally. It was
          born in September 2018 during ETHBerlin and has been growing in
          contributors ever since.


          #### Using your app to access GraphQL data


          * The preferred method is to utilize a client library that can handle
          the 'plumbing' to ensure you have up-to-date data (with caching
          sometimes included).  Apollo is used internally, but there are several
          choices depending on your programming language; read the official
          GraphQL page for more information.

          * If you are unable to utilize a client library (for example, while
          querying using Postman), you can send a POST request to our subgraph's
          HTTP endpoint with the header: "Content-Type: application/json" and
          the body comprising of your query on one line in quotations. As an
          example:

          ```

          {"query": "{ reserves (where: {usageAsCollateralEnabled: true})  { id
          name price {id} liquidityRate variableBorrowRate stableBorrowRate}}" }

          ```
      - title: >-
          Querying Aave's GraphQL database using React and implementing a Pie
          chart
        shortTitle: React App
        key: react-app
        details: >
          * **Initial Setup**
            First, we create a React project, you can refer [this](https://create-react-app.dev/docs/getting-started/) documentation.
            Run npm start to check if the project runs fine.

          * **Integrate ApolloClient**
            Then we integrate the Apollo client library. We can install and setup the client using [this](https://www.apollographql.com/docs/react/get-started/) documentation.
            We can use the sample code to fetch the data and test our setup.

          * **Initialize the ApolloClient**
            With our dependencies already set up, we can now create an ApolloClient instance.
            We start by importing the symbols we require from @apollo/client into index.js.
            Next, we initialize ApolloClient by handing it a configuration object including the uri and cache fields.

          * **Connect the client to React**
            We can connect Apollo Client to React with the ApolloProvider component. Similar to React's Context.Provider, ApolloProvider wraps our React app and places Apollo Client on the context, enabling us to access it from anywhere in our component tree.
            In index.js, we wrap our React app with an ApolloProvider.

          * **Fetching data with useQuery**
            After the ApolloProvider is hooked up, we can start requesting data with useQuery. The useQuery hook is a React hook that shares GraphQL data with your UI.
            We can define the query we want to execute by wrapping it in the gql template literal.
            Next, we define a component named DisplayGraphs that executes our GET_QUERY query with the useQuery hook:

          * **Implementing the Pie Chart**
            Now, our aim is to create a pie chart using the data we receive. So now we use [react-chartjs-2](https://react-chartjs-2.js.org/). We will import it in our App.js.
            Then we initialize our code to get a Pie chart. Finally we will add the code to get our Pie chart.

          * This will give us a Pie chart in our React app.

          * You can get the complete code
          [here](https://github.com/DoDAO-io/aava-analytics-sample-app).
      - title: Historical Rest Data
        shortTitle: Historical Rest Data
        key: historical-rest-data
        details: >
          * Now we will use the [Aave Protocol
          API](https://aave-api-v2.aave.com/) to create a time series graph.

          * We will use the same react application to create the time series
          graph too, so if you still haven't create a react app by following the
          previous steps.

          * Since the the [Aave Protocol API](https://aave-api-v2.aave.com/) is
          for v2 mainnet so now we need to query the Aave v2 mainnet subgraph.

          * We need to make the fetch requests from
          https://aave-api-v2.aave.com/#/data/get_data_rates_history to get the
          time series data for any Aave reserve. 

          * If you visit the above link, you can see that we require a reserveID
          to fetch the data (there is a sample reserveID already provided in
          case you want to try it out). So to get this reserveID, we will query
          the Aave v2 mainnet subgraph
          (https://thegraph.com/hosted-service/subgraph/aave/protocol-v2 ). We
          have already queried the reserveIDs for ChainLink Token
          (0x514910771af9ca656af840dff83e8264ecf986ca0xb53c1a33016b2dc2ff3653530bff1848a515c8c5)
          and TrueUSD
          (0x0000000000085d4780b73119b644ae5ecd22b3760xb53c1a33016b2dc2ff3653530bff1848a515c8c5)
          which we will be using to plot the graph. 

          * We query an array of objects which contains the pools with the
          reserves id, name and symbol.

          * Also, in the GET request we need to provide the start date (from)
          and time interval (resolutionInHours) to fetch the data. You can use
          [this](https://www.epochconverter.com/) UNIX timestamp convertor to
          change the date.

          * So now you can visit the aave protocol api and playaround with
          different reserveID, from and resolutionInHours.

          * Now, we visit our App.js and add some changes to code to get our
          desired graph and add some import statements as we need to use Line
          Chart this time to represent the time series data.

          * Now, we need to fetch the get requests so for that we will use the
          useEffect hook from React and store the data using useState hook. So
          add the following code to your DisplayGraphs functions.

          * The Get request also returns some unwanted data and the timestamp is
          in a format which we don't like much, so we update it.

          * Finally, we create the Line chart.

          * You can get the complete code
          [here](https://github.com/DoDAO-io/aava-analytics-sample-app). 
uuid: aave-developer-1
