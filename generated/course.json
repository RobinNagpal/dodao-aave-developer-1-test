{
  "key": "aave-developer-1",
  "title": "AAVE Developer 1 (In Progress)",
  "summary": "This is a technical course for developers willing to write applications on AAVE.\n",
  "details": "In this course we cover the following\n1) Chapter 1 - Information about various smart contracts of AAVE\n2) Chapter 2 - How to pull data from Aave which can be used to create analytics applications\n3) Chapter 3 - How to setup a developer environment to interact with Aave's smart contracts\n4) Chapter 4 - Interacting with Aave's Smart Contracts",
  "duration": "1 - 2 hours",
  "highlights": [
    "AAVE Smart Contract Introduction",
    "Fetching AAVE Data",
    "Developer Environment Setup",
    "Writing simple UI application on top of AAVE"
  ],
  "publishStatus": "Live",
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/courses/DoDAO/DeFi/defi_logo.jpeg",
  "topics": [
    {
      "title": "AAVE Smart Contracts",
      "key": "aave-smart-contracts",
      "details": "This chapter taks about various important smart contracts of AAVE which forms the basis of lending and borrowing\n",
      "order": 0,
      "explanations": [
        {
          "key": "aave-smart-contracts-intro",
          "shortTitle": "Introduction",
          "details": "Aave is a decentralized finance protocol that facilitates lending and borrowing of cryptocurrency tokens usAave ing diverse algorithms and smart contracts without the presence of centralized intermediaries. \nIt is a non-custodial liquidity protocol that allows users to participate as depositors or borrowers. Depositors provide liquidity to the market to earn a passive income, while borrowers are able to borrow in an overcollateralized manner.\n\nAave's transition from a decentralized P2P lending approach (a direct loan relationship between lenders and borrowers, similar to ETHLend) to a pool-based strategy is marked by the creation of the Aave Protocol. By putting cryptocurrency in a pool contract, lenders offer liquidity. The pooled funds can also be borrowed inside the same contract by pledging collateral. Loans rely on the pooled money as well as the quantities borrowed and their collateral rather than on individual matching. This makes it possible to quickly lend money with terms that depend on the condition of the pool. Figure 1 below shows a simplified version of the protocol's structure.\n\n![AAVE](https://github.com/DoDAO-io/dodao-aave-developer-1-course/blob/6bd13f67bbb027bc58280c103f78b0b29d5ad810/images/aave.jpg?raw=true)\n`Reference: https://docs.aave.com/developers/v/2.0/`\n\nThe participants lending the tokens get interest on their loan and the participants borrowing the tokens pay interest. An individual can lend and borrow simultaneously via Aave.\nThe working mechanism of Aave involves allocating a platform specific token, called aTokens to a user's crypto investment. \nThis is what lenders get when they deposit their assets into the pool.\nFor instance, a user who deposits Ethereum in Aave will hold aETH on Aave. \naToken is based on a particular crypto asset and the interest rate each aToken earns is specific to the token deposited, depending on the supply and demand for the original coin.\n\nAave Protocol was created with security in mind and has been audited by various auditors.\nThe White Paper provides a more in-depth look at the protocol, economics, and how it operates.\nOn Github, the Aave Protocol repository can be found here: https://github.com/aave/.\n\n#### Lending and borrowing\nAave has a smart contract based working mechanism wherein the interest rates are determined by different algorithms.\nThe depositors lend the funds in the liquidity pools and earn interest, similarly borrowers can borrow the funds from the liquidity pools. \n\nThe interest rate for both borrowers and lenders is decided algorithmically:\n\n* **Interest rate for Borrowers**: The interest rate to be paid by the borrowers depends on the cost of money and the amount of funds available in the pool at a specific time.The amount of funds present in the pool has an inverse relationship with the interest rate. As funds are borrowed from the pool, the amount of funds available decreases which raises the interest rate. \n\n* **Interest rate for Lenders**: The interest rate received by the lenders corresponds to the earn rate, with the algorithm safeguarding a liquidity reserve to guarantee withdrawals at any time.\n\nAnd since cryptocurrency is highly volatile, borrowing in Aave demands overcollateralization. \nFor example-  Kevin wants to borrow $500 worth of ETH from the AAve protocol. In order to do so, Kevin will have to put up more than that amount in a different cryptocurrency. If the price falls and the amount in collateral no longer covers the amount borrowed, the collateral can be liquidated, meaning the protocol takes it to cover the cost of the loan.\nA liquidation event happens when the price of the collateral drops below the liquidation threshold.\n",
          "title": "Introduction"
        },
        {
          "title": "Important Tech Terms",
          "shortTitle": "Tech Terms",
          "key": "terminology",
          "details": "* **APY**: Annual Percentage Yield is the yield/interest after a year, including compounding interest. This differs from the Annual Percentage Rate (APR), which does not account for compounding effects.\n\n* **Liquidity Index**: The reserve's interest accumulation during the time span since the last updated timestamp.\n\n* **Loan To Value**: The maximum borrowing capacity of a particular collateral. If a collateral has a Loan to Value of 75%, the user will be allowed to borrow 0.75 ETH of primary currency for every 1 ETH of collateral. The Loan To Value is represented in percentage points and is set per collateral.\n\n* **Liquidation Threshold**: The amount of a borrow position that must be liquidated because it is undercollateralized. When a collateral has an 80% liquidation threshold, it signifies that the loan will be liquidated when the debt value equals 80% of the collateral value. The liquidation threshold is defined in percentage points and is specified per collateral.\n\n* **Liquidation Bonus**: The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor less than one. The Liquidation Bonus is defined in percentage points and is determined per collateral.\n\n* **Health factor**: The ratio of total collateral multiplied by the liquidation threshold to borrowed principal. When the Health Factor falls below one, the loan is considered undercollateralized and can be liquidated.\n\n* **Stable rate**: A loan with a stable rate behaves like a fixed rate loan in the short term, but the rates can be rebalanced in the medium/long term in response to rapid market movements.\n\n* **Reserve** : Reserves are the underlying assets' ERC-20 contracts.\n\n* **Variables in Code**\nFollowing is the list of most common variables used in the code:\n\n| Parameter Name             | Type            | Description                                                                                                                                            |\n| -------------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| reserve                    | address         | address of the [underlying asset](https://docs.aave.com/developers/v/1.0/deployed-contracts/deployed-contract-instances#reserves-assets)               |\n| amount                     | uint256         | amount to borrow/deposit/repay, expressed in decimal units                                                                                             |\n| referralCode               | uint256         | referral code for the referral program                                                                                                                 |\n| useAsCollateral            | bool            | if true, the asset is allowed as a collateral for borrow                                                                                               |\n| interestRateMode           | uint256         | type of interest rate mode to use, with uint 2 representing variable rate and uint 1 representing stable rate                                          |\n| onBehalfOf                 | address payable | address to repay on behalf of. If the caller is repaying their own loan, then this value should be equal to msg.sender                                 |\n| user                       | address         | address of the user to rebalance                                                                                                                       |\n| collateral                 | address         | address of the liquidated collateral reserve                                                                                                           |\n| purchaseAmount             | uint256         | amount of the discounted purchase                                                                                                                      |\n| receiveaToken              | bool            | if true, the user receives the aTokens equivalent of the purchased collateral. If false, the user receives the underlying asset directly               |\n| timestamp                  | uint256         | timestamp of the transaction, in Unix time                                                                                                             |\n| borrowRateMode             | uint256         | interest rate mode 0 for None, 1 for stable and 2 for variable                                                                                         |\n| borrowRate                 | uint256         | APY of the loan at the time of the borrow() call. in Wei.                                                                                              |\n| originationFee             | uint256         | amount of the originationFee of the loan, in [Ray units](https://docs.aave.com/developers/v/1.0/developing-on-aave/important-considerations#ray-math). |\n| borrowBalanceIncrease      | uint256         | amount of debt increased since the last update by the user, in Wei.                                                                                    |\n| repayer                    | uint256         | address of the repayer                                                                                                                                 |\n| amountMinusFees            | uint256         | amount repayed, without fees.                                                                                                                          |\n| fees                       | uint256         | fees paid                                                                                                                                              |\n| purchaseAmount             | uint256         | amount of the liquidation, in Wei.                                                                                                                     |\n| liquidatedCollateralAmount | uint256         | amount of collateral being liquidated                                                                                                                  |\n| accruedBorrowInterest      | uint256         | amount of debt increased since the last update by the user, in Wei.                                                                                    |\n| liquidator                 | address         | address of the liquidator                                                                                                                              |\n| receiveAToken              | bool            | true if the liquidator wants to receive aTokens, false otherwise.                                                                                      |\n"
        },
        {
          "key": "architecture",
          "title": "AAVE Architecture",
          "shortTitle": "Architecture",
          "details": "Aave has released three versions (v1, v2 and v3) as of now and the Governance token of Aave is \"AAVE\". Version 1 or v1 is the base version launched in 2017 and then there have been upgrades with multiple new features added. \nAave v2 improves on many areas of v1, allowing developers to create a wide new design space in which to construct products and services. If you previously developed on Aave v1, you should be aware of the following changes:\n* There is no longer a LendingPoolCore contract in Aave v2 that retains all of the protocol's assets. Assets are held directly in the linked aToken contracts, with the LendingPool contract serving as the protocol's \"core.\"\n* Almost all actions in Aave v2 should be executed via the LendingPool contract. This differs from v1, when a redemption/withdrawal of aTokens required a call on the aToken contract.\n* After depositing collateral into the protocol, a user can easily delegate credit to any address by using approveDelegation() on the relevant debt token.\n* Flash loans are possible inside the Aave v2 protocol. Indeed, they are widely utilised within the protocol for position switching and other 'trading'-like functions.\n* Flash loans can now be executed in batches, which means that many flash loans with varied parameters can be performed in the same call. This opens the door to strong new use cases, such as repaying numerous assets and positions with a single flash loan transaction.\n* You can now do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt (i.e. the flash loan is not paid back immediately).\n* AddressesProviders will be numerous in multiple markets. The AddressesProviderRegistry will keep track of all Aave market address providers.\n* LendingPoolCore has been decommissioned. Only LendingPool is used, which simplifies integrations and Aave v2 development.\nThe v3 improved features enable new use cases, sparking a flood of innovation from users and developers. Aave V3 generates I mprovements in all of the these areas - capital efficiency, security, decentralisation, and UX - while simultaneously delivering new functions to harness the capabilities of rollups and the developing ecosystem of rival L1s.\n* Portal is a new set of core functionalities that can be utilised to enable provided assets to move easily between Aave markets on different networks. On the surface, the feature is fairly simple: the protocol uses the aTokens' unique pegged design to burn aTokens on the source network while minting them on the destination network.\n* Borrowers can use High Efficiency Mode (E-Mode) to get the most borrowing power out of their collateral. Borrowers can use E-Mode to limit their borrowing to only assets in a specific category (e.g., stablecoins).\n* One of the most important areas for improvement is managing the inherent complexities of risk exposure modulation.\n* Repay with aTokens: Allows borrowers to repay with aTokens rather than the underlying asset.\n* Despite all of the new features, the overall gas cost of all functions fell by about 25%.\n* Smart contract re-engineering has considerably reduced code size (leaving more room for future revisions) by up to 100K optimizer runs!\n* All token transfer functions (supply, repay) now support EIP 2612 authorization (this is especially important for L2).\n* Signature on EIP 712 for credit delegation (no need for contracts to request a user transaction anymore).\n\n#### Protocol Overview\n\nOn Github, the Aave Protocol repository can be found here: https://github.com/aave/\nBelow image provides an overview of the protocol.\n\n![Architecture](https://github.com/DoDAO-io/dodao-aave-developer-1-course/blob/6bd13f67bbb027bc58280c103f78b0b29d5ad810/images/architechture.png?raw=true)\n`Reference: https://docs.aave.com/developers/v/2.0/the-core-protocol/protocol-overview`\n\n#### Main Contracts\nThe main contracts in Aave and their purposes are:\n* LendingPool: The main entry point into the Aave Protocol. Most interactions with Aave will happen via the LendingPool, including:\n  - `deposit()`\n  - `borrow()`\n  - `repay()`\n  - `swapBorrowRateMode()`\n  - `setUserUseReserveAsCollateral()`\n  - `withdraw()`\n  - `flashloan()`\n  - `liquidationCall()`\n* LendingPoolAddressesProvider: The protocol's primary addresses register for specific marketplaces. The most recent contract addresses should be obtained from this contract by making the necessary calls.\n* LendingPoolAddressesProviderRegistry: Contains a list of active LendingPoolAddressesProvider addresses, for different markets.\n* aTokens: The yield-producing, tokenized deposits that are used throughout the Aave protocol. They implement, with minor modifications, the majority of the standard EIP-20/ERC20 token methods, as well as Aave-specific methods such as:\n  - `scaledBalanceOf()`\n  - `getScaledUserBalanceAndSupply()`\n  - `scaledTotalSupply()`\n\n  All aTokens also implement EIP-2612, which via the permit() function enables gas-less transfers and single transaction approve + actions.\n* Stable and Variable Debt Tokens: The Aave protocol employs tokenised borrow locations throughout. Because debt tokens are non-transferable, most common EIP-20/ERC20 techniques are disabled.\n\n#### Supporting contracts\nThe following contracts should generally not be interacted with directly, but are used throughout the Aave Protocol via contract calls.\n* LendingPoolCollateralManager: The LendingPoolCollateralManager implements protocol activities involving collateral management using delegatecall via the LendingPool contract, including:\n  - liquidationCall()\nOnly the primary LendingPool contract should be used to call the above function.\n* Lending Pool Configurator: Configuration functions for LendingPool contracts are provided. It also serves a variety of vital purposes:\n  - Activates / Deactivates reserves,\n  - Enables / Disables borrowing for a reserve,\n  - Enables / Disables using a reserve as collateral,\n  - Enables / Disables stable rate borrowing for a reserve,\n  - Freezes / Unfreezes reserves,\n  - Updates a reserve's Loan to Value,\n  - Updates a reserve's liquidation threshold,\n  - Updates a reserve's liquidation bonus,\n  - Updates a reserve's decimals,\n  - Updates a reserve's interest rate strategy address,\n  - Activates / Deactivates all functions of a LendingPool in emergencies.\n\n  For all of the above functions, relevant events are emitted to the blockchain. Anyone can monitor these changes to know when values have been modified or added/removed.\n* Interest Rate Strategy: Contains the data required to calculate and adjust the interest rates on individual reserves.\nEach contract stores the optimised base curves using the relevant currency parameters. This means that each asset pool's interest rate is determined by a mathematical function, with the interest rate varying based on the amount of borrowed funds and the asset pool's total liquidity (i.e. utilisation).\nThe parameters for the optimised base curves are:\n  - baseVariableBorrowRate\n  - variableRateSlope1\n  - variableRateSlope2\n  - stableRateSlope1\n  - stableRateSlope2\n\nThe interest rates are calculated depending on the available liquidity and the total borrowed amount.\n"
        },
        {
          "key": "functions-1",
          "title": "AAVE Functionalities in Details - I",
          "shortTitle": "Functions - I",
          "details": "The LendingPool contract is the protocol's principal contract. It exposes all user-oriented operations that may be performed with the Solidity or web3 libraries. The source code is available [here](https://github.com/aave/aave-protocol/blob/master/contracts/lendingpool/LendingPool.sol).\nTo concentrate on method interactions, Web3 code samples remove imports and transactional sections. Join the #developers channel on the [Aave community Discord server](https://discord.gg/fVaDMqT) if you require development assistance.\n\n#### Deposit/Lending\nLenders share the interest payments made by borrowers based on the utilization rate multiplied by the average borrowing rate. The yield for depositors increases as reserve utilization increases.\nLenders are also entitled to a portion of the Flash Loan fees, equal to 0.09% of the Flash Loan volume.\nThere is no minimum or maximum deposit amount; you may deposit any amount you choose.\n\n#### Methods\n####  `function deposit( address _reserve, uint256 _amount, uint16 _referralCode)`\n\nDeposits a certain `_amount` of an asset specified by the `_reserve` parameter.\nIn exchange, the caller receives a specific number of aTokens. aTokens can be redeemed for the underlying token in a 1:1 ratio.\n\nPlease see the referral programme section for further information about `_referralCode` input. You can use the referral code: 0 during testing.\n\nWhen depositing an ERC-20 token, the `LendingPoolCore` contract (not the `LendingPool` contract) must have the required allowance of `_amount` for the underlying ERC20 of the `_reserve` asset via `approve()`.\nEmitted events: `_reserve`, `_user`, `_amount`, `_referral`, `_timestamp`\n\n**ETH deposits**\nBecause the protocol does not employ an EIP-20 wrapper like wETH for ETH deposits, the deposit() method's amount parameter must match the transaction's msg.value parameter and be included in your deposit() call.\nE.g: `lendingPool.deposit{ value: msg.value }(reserve, msg.value, referralCode)`\nBecause ETH is utilized directly in the protocol (rather than an abstraction like WETH), we use a dummy address to represent it: `0xEeeeeEeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n\n**ERC20 deposits**\nThe _reserve parameter corresponds to the underlying asset's ERC20 contract address. [Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L753)\n\nThe deposit() flow within the protocol:\n<div class=\"flex justify-center max-h-96\">\n<img src=\"https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH4HvCIm09jkjFv%2Flending%20pool%20deposit.png?alt=media&token=c92f8256-9d73-41a1-9e96-a3d807425d08\" />\n</div> \n\n#### `function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral)`\n\nAllow the user's deposit to be used as collateral. Users will only be able to disable deposits that are not being used as collateral at the time. [Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L341 )\n\n**Stable vs Variable Interest Rate**\n\nIn the short-term, stable rates function as a fixed rate, but they can be rebalanced in the long run in reaction to alterations in the market environment. Depending on supply and demand in Aave, the variable rate can change.\nThe stable rate is the better choice for forecasting how much interest you will have to pay because, as its name suggests, it will remain fairly stable. The variable rate changes over time and, depending on market conditions, could be the optimal rate.\n"
        },
        {
          "key": "functions-2",
          "title": "AAVE Functionalities in Details - II",
          "shortTitle": "Functions - II",
          "details": "#### Borrow\nYou must deposit any asset to be used as collateral before borrowing.The amount you can borrow depends on the value you have deposited and the readily available liquidity.For instance, if there isn’t enough liquidity or if your health factor (minimum threshold of the collateral = 1, below this value, liquidation of your collateral is triggered) prevents it, you can’t borrow an asset. The loan is repaid with the same asset that you borrowed.\nFor instance, if you borrow 1 ETH, you’ll need to pay back 1 ETH plus interest.\nIn the updated Version 2 of the Aave Protocol, you can also use your collateral to make payments. You can borrow any of the stablecoins like USDC, DAI, USDT, etc. if you want to repay the loan based on the price of the USD.\n\n#### Methods\n#### borrow()\n**function borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode)** \nTransfers a certain amount of the asset identified by the _reserve parameter to the msg.sender, provided the caller has deposited enough collateral to fund the borrow in advance.\nEvery loan can be opened in either a fixed or variable rate mode. Borrows have an indefinite term and no payback date. In the event of market swings, a borrow position is liquidated if the collateral price falls below a specific threshold. Please read the White Paper to learn more about the stable rate economy.\nPlease see the [referral programme section](https://docs.aave.com/developers/v/1.0/integrating-aave/referral-program) for further information about _referralCode input. You can use the referral code: 0 during testing.\nEmitted events: _reserve, _user, _amount, _referral, _timestamp, _borrowRateMode, _borrowRate, _originationFee, _borrowBalanceIncrease\n\n[Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L219 )\n\nThe borrow() flow within the protocol:\n<div class=\"flex justify-center max-h-48\">\n<img src=\"https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH3GOEvYvbizwHC%2Flending%20pool%20borrow.png?alt=media&token=2031b536-733e-4a8a-866c-23c86706e641\" class=\"max-h-48\" />\n</div> \n\n#### repay()\n**function repay( address _reserve, uint256 _amount, address payable _onBehalfOf)**\nRepay a borrowed asset in whole or in part. The _onBehalfOf parameter can be used to repay a different user's debt.\nWhen a third-party repays another user's debt on their behalf, the third-party address must approve() the LendingPoolCore contract (which is separate from the LendingPool contract) with the _amount of the underlying ERC20 of the _reserve contract.\nEmitted events: _reserve, _user, _repayer, _fees, _referral, _timestamp, _amountMinusFees, _borrowBalanceIncrease\n\n[Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L249)\n\nThe repay() flow within the protocol: \n<div class=\"flex justify-center max-h-48\">\n<img src=\"https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH9NighH7i_73lI%2Flending%20pool%20repay.png?alt=media&token=cb6e102e-222b-412a-92f0-763ae34e7cce\" />\n</div>  \n\n#### swapBorrowRateMode()\n**function swapBorrowRateMode(address _reserve)**\nChanges the borrow rate modes of the msg.sender from stable to variable.\n[Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L326) \n\n#### rebalanceStableBorrowRate()\n**function rebalanceStableBorrowRate(address _reserve, address _user)**\nRebalances the stable rate of _user\n[Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L336) \n\nThe rebalance flow for stable rates in the protocol: \n<div class=\"flex justify-center max-h-48\">\n<img src=\"https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH7rY4WFE5jRwrB%2Flending%20pool%20rebalancing.png?alt=media&token=8a442d62-6087-4adf-b27b-163478547f79\" />\n</div>   \n\n#### liquidationCall()\n**function liquidationCall(address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveaToken)**\nPositions with a health factor less than one should be liquidated.\nWhen a position's health factor falls below one, liquidators repay part or all of the outstanding borrowed amount on behalf of the borrower in exchange for a discounted quantity of collateral (sometimes known as a liquidation \"bonus\"). Liquidators have the option of receiving an equal quantity of collateral aTokens or the underlying asset directly. When the liquidation is completed successfully, the position's health factor is enhanced, bringing it above 1.\nA close factor determines how much collateral a liquidator can close. The current close factor is 0.5. In other words, liquidators can only liquidate up to 50% of the amount owing in a position. This is the amount of the liquidation discount.\nLiquidators must approve() the LendingPoolCore contract (which is distinct from the LendingPool contract) in order to use the underlying ERC20 of the _reserve asset for the liquidation.\n**NOTE**: In most cases, profitable liquidators will choose to liquidate as much of the _user position as possible.\npurchaseAmount parameter can be set to uint(-1) and the protocol will proceed with the largest liquidation allowed by the close factor.\nFor ETH liquidations, the transaction's msg.value should be identical to the _purchaseAmount parameter.\nTo determine a user's health factor, use getUserAccountData().\n[Code Here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L360) \n\nThe liquidation flow in the protocol:\n<div class=\"flex justify-center max-h-48\">\n<img src=\"https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH6dX0q9LDXBn9X%2Flending%20pool%20liquidation.png?alt=media&token=6701e381-1fd1-42ce-919b-39da57434c57\" />\n</div>   \n"
        },
        {
          "title": "AAVE Functionalities in Details - III",
          "shortTitle": "Functions - III",
          "key": "functions-3",
          "details": "Flash Loans are special transactions that allow you to borrow an asset as long as the borrowed amount (plus a fee) is returned before the transaction ends (also called One Block Borrows). These transactions do not necessitate the provision of collateral by the user prior to the transaction. Because there is no real-world equivalent for Flash Loans, some basic grasp of how the state is managed within blocks in blockchains is required.\nDue to the technical understanding necessary to execute one, flash loans are a feature developed for developers. To use this feature, you must have a solid understanding of EVM, programming, and smart contracts. To do a Flash Loan, you must first create a contract requesting a Flash Loan. The contract must follow the instructions and repay the loan plus interest and fees in the same transaction.\n\nCan you use Flash Loans without knowing how to code?\nYes, there are currently programs available that enable end users to gain from Flash Loans, such as [defisaver](https://defisaver.com/) and [collateralswap](https://collateralswap.com/). At https://medium.com/aave/sneak-peek-at-flash-loans-f2b28a394d62 , you may find more application cases.\nEven those without coding experience may use Flash Loans because of user interfaces like the one [furucombo](https://furucombo.app/) offers. Details are provided below: https://medium.com/furucombo/create-flashloan-combo-on-furucombo-c7c3b23267f0 \n\nAave v3 provides two flash loan options:\n**flashLoan**: Allows the borrower to obtain liquidity from various reserves in a single flashLoan transaction. In this instance, the borrower has the option of opening a stable or variable rate debt position backed by supplied collateral or credit delegation.\n**NOTE**: For qualified flashBorrowers, the loan charge is waived (managed by ACLManager)\n**flashLoanSimple**: Allows the borrower to access a single reserve of liquidity for the transaction. In this situation, the flash loan fee is not waived, and the borrower is not permitted to open any debt positions at the conclusion of the transaction. For individuals attempting to take advantage of a simple flash loan with a single reserve asset, this strategy is gas efficient.\n\n#### Flow of Execution\nA helpful mental model to consider when creating your solution for developers:\n* Your contract contacts the Pool contract and requests a Flash Loan for a specific amount(s) of reserve(s) using flashLoanSimple() or flashLoan() ().\n* The Pool sends the requested amounts of reserves to your contract after some sanity checks, then executes executeOperation() on the receiver contract.\n* Your contract now does any arbitrary operation in its code while holding the flash borrowed amount(s).\n* When you finish your code for a flashLoanSimple, you approve Pool for the flash loaned amount + charge.\n* If you are executing flashLoan, then all reserves must be granted for flash borrowed amount + fee or adequate collateral or credit delegation must be provided to start debt position, based on the interestRateMode passed for the asset.\n* If the amount owed is not available (due to a lack of balance or authorisation, or insufficient debt collateral), the transaction is reverted.\n* All of the preceding occurs in a single transaction (hence in a single ethereum block).\n\n#### Flash Loan Applications\nAave Flash Loans are already used for the liquidity swap functionality in Aave V3. Other real-world instances include: arbitrage between assets without requiring the main amount to be present.\nLiquidating borrow positions without having to repay the debt of the positions and paying off flashLoan amount + charge with discounted collateral claimed.\n\n#### Fee for a Flash loan\nThe flash loan charge is set to 0.09% at deployment and can be changed via Governance Vote. To obtain the current value, use FLASHLOAN PREMIUM TOTAL.\nThe LPs (liquidity providers) and the protocol treasury can split the flashloan charge. The FLASHLOAN PREMIUM TOTAL variable represents the total charge paid by borrowers, which includes:\nFee to LP: FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL\nFee to Protocol: FLASHLOAN_PREMIUM_TO_PROTOCOL\nAt initialization, FLASHLOAN_PREMIUM_TO_PROTOCOL is 0.\n\n#### First step: Setting Up\nBy implementing the relevant executeOperation() function, your contract that receives the amounts from flash loans must comply with the IFlashLoanSimpleReceiver.sol or IFlashLoanReceiver.sol interface.\nAdditionally, keep in mind that since the owing sums will be deducted from your contract, your contract must let the Pool to deduct those monies in order to repay the flash loan amount plus premiums.\n\n#### Second Step: Calling flashLoan() or flashLoanSimple()\nTo invoke either of the Pool's two flash lending methods, we must provide the necessary parameters. There are three possibilities:\n* From an EOA ('normal' Ethereum account)\n  - To use an EOA, send a transaction to the appropriate Pool and use the flashLoan() or flashLoanSimple() functions. For parameter information, see the Pool API documentation, making sure to use your contract address from step 1 for the receiverAddress.\n* From a different contract\n  - As with transmitting a transaction from an EOA, make sure the receiverAddress matches your contract address from step 1.\n* From the same contract\n  - Utilize address(this) for the receiverAddress parameter in the flash loan method if you wish to use the same contract as in step 1.\n**Note**: Never keep funds permanently on your FlashLoanReceiverBase contract as they could be exposed to a ['griefing' attack](https://ethereum.stackexchange.com/a/92457/19365), where the stored funds are used by an attacker.\n\n#### Final Step: Completing the flash loan\nIf you used flashLoanSimple() or interestRateMode=0 in flashLoan() for any of the assets in the modes parameter, you will need to repay the flash loaned amounts once you have completed your logic with the flash loaned assets (in your executeOperation() method).\n* Repaying a flash loaned asset\n  - Check that your contract includes the appropriate amount + premium to repay the borrowed asset. This can be calculated by adding the relevant entries in the amounts and premiums array given to the executeOperation() function. \\\n  - You are not required to return the owing sum to the Pool. The cash will be automatically withdrawn at the end of your operation.\n* Getting into debt (i.e. not immediately paying back)\n  - If you used mode=1 or mode=2 for any of the assets in the modes parameter, the address put in for onBehalfOf will incur the obligation if the onBehalfOf address previously authorised the msg.sender to incur debts on their behalf.\n  - This means that you can have some assets that are promptly paid back while others incur debt.\n"
        }
      ],
      "questions": [
        {
          "uuid": "7e267f35-7837-4aa9-9081-9ec8ab708a79",
          "type": "SingleChoice",
          "content": "Select the correct option.",
          "hint": "NoHint",
          "explanation": "Since cryptocurrency is highly volatile, borrowing in Aave demands overcollateralization.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "aave-smart-contracts-intro"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Borrowing in Aave is undercollateralized",
              "key": "A"
            },
            {
              "content": "Borrowing in Aave is overcollateralized",
              "key": "B"
            },
            {
              "content": "Depositing in Aave is overcollateralized",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "98442878-4460-4bdd-88f0-1b2a9bce6dfd",
          "type": "SingleChoice",
          "content": "When does a liquidation event occur?",
          "hint": "NoHint",
          "explanation": "A liquidation event happens when the price of the collateral drops below the liquidation threshold.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "aave-smart-contracts-intro"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "When the price of the collateral rises above the liquidation threshold",
              "key": "A"
            },
            {
              "content": "When the price of the collateral is equal to the liquidation threshold",
              "key": "B"
            },
            {
              "content": "When the price of the collateral drops below the liquidation threshold",
              "key": "C"
            },
            {
              "content": "When the price of the collateral doubles the liquidation threshold",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "db260d6f-9851-459f-9170-b59d73460723",
          "type": "SingleChoice",
          "content": "What is Liquidation Bonus?",
          "hint": "NoHint",
          "explanation": "Liquidation bonus is the bonus paid to liquidators to encourage the purchase of specified collateral with a health factor less than one",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "terminology"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor more than one",
              "key": "A"
            },
            {
              "content": "The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor equal to one",
              "key": "B"
            },
            {
              "content": "The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor more than or equal to one",
              "key": "C"
            },
            {
              "content": "The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor less than one",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b8d4ad4a-c761-47f2-ad99-2904f842fbd2",
          "type": "SingleChoice",
          "content": "What is the maximum borrowing capacity of a particular collateral known as?",
          "hint": "NoHint",
          "explanation": "Loan To Value is the maximum borrowing capacity of a particular collateral. If a collateral has a Loan to Value of 75%, the user will be allowed to borrow 0.75 ETH of primary currency for every 1 ETH of collateral. The Loan To Value is represented in percentage points and is set per collateral.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "terminology"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Liquidation Threshold",
              "key": "A"
            },
            {
              "content": "Liquidity Index",
              "key": "B"
            },
            {
              "content": "Loan To Value",
              "key": "C"
            },
            {
              "content": "Liquidation Bonus",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "619a9931-752e-4a4e-b88b-7700603d1c51",
          "type": "SingleChoice",
          "content": "What do you understand by liquidation threshold?",
          "hint": "NoHint",
          "explanation": "Liquidation Threshold is the amount of a borrow position that must be liquidated because it is undercollateralized. When a collateral has an 80% liquidation threshold, it signifies that the loan will be liquidated when the debt value equals 80% of the collateral value. The liquidation threshold is defined in percentage points and is specified per collateral.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "terminology"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The amount of a borrow position that must be liquidated because it is undercollateralized",
              "key": "A"
            },
            {
              "content": "The ratio of total collateral multiplied by the liquidation threshold to borrowed principal",
              "key": "B"
            },
            {
              "content": "The amount of a borrow position that must be liquidated because it is overcollateralized",
              "key": "C"
            },
            {
              "content": "The maximum borrowing capacity of a particular collateral",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3326b2c9-6f6e-4f38-b724-2f5a3d758d1f",
          "type": "SingleChoice",
          "content": "How many versions of the AAVE protocol have been released?",
          "hint": "NoHint",
          "explanation": "Aave has released three versions (v1, v2 and v3) as of now.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "versions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "One",
              "key": "A"
            },
            {
              "content": "Two",
              "key": "B"
            },
            {
              "content": "Three",
              "key": "C"
            },
            {
              "content": "Zero",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "fb570d02-88db-425f-8d8f-3f4f8a38b9ce",
          "type": "SingleChoice",
          "content": "What is Health Factor?",
          "hint": "NoHint",
          "explanation": "Health factor is the ratio of total collateral multiplied by the liquidation threshold to borrowed principal. When the Health Factor falls below one, the loan is considered undercollateralized and can be liquidated.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "terminology"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The ratio of total collateral multiplied by the liquidation threshold to borrowed principal",
              "key": "A"
            },
            {
              "content": "The ratio of total collateral multiplied by the borrowed principal to liquidation threshold",
              "key": "B"
            },
            {
              "content": "The ratio of total collateral to borrowed principal",
              "key": "C"
            },
            {
              "content": "The ratio of total collateral to liquidation threshold",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2613cb0b-1247-4471-b174-f5ff2f7fbc47",
          "type": "SingleChoice",
          "content": "Which contract has been decommissioned in Aave v2?",
          "hint": "NoHint",
          "explanation": "LendingPoolCore has been decommissioned. Only LendingPool is used, which simplifies integrations and Aave v2 development.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "versions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "LendingPoolAddressesProvider",
              "key": "A"
            },
            {
              "content": "LendingPool",
              "key": "B"
            },
            {
              "content": "LendingPoolCore",
              "key": "C"
            },
            {
              "content": "LendingPoolAddressesProviderRegistry",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "5d69612e-6241-4bfc-a247-b7ef12f9e9c0",
          "type": "MultipleChoice",
          "content": "Pick the correct option(s).",
          "hint": "NoHint",
          "explanation": "Flash loans can now be executed in batches, which means that many flash loans with varied parameters can be performed in the same call. This opens the door to strong new use cases, such as repaying numerous assets and positions with a single flash loan transaction. You can now do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt (i.e. the flash loan is not paid back immediately).",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "versions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Many flash loans with varied parameters can now be performed in the same call",
              "key": "A"
            },
            {
              "content": "Many flash loans with varied parameters can not be performed in the same call",
              "key": "B"
            },
            {
              "content": "You can now do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt",
              "key": "C"
            },
            {
              "content": "You can not do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1e7412d2-0f89-4fd1-b742-5ea072b8efb6",
          "type": "SingleChoice",
          "content": "Which contract is the main entry point into the Aave Protocol?",
          "hint": "NoHint",
          "explanation": "LendingPool is the main entry point into the Aave Protocol. Most interactions with Aave will happen via the LendingPool.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "overview"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "LendingPoolAddressesProvider",
              "key": "A"
            },
            {
              "content": "LendingPool",
              "key": "B"
            },
            {
              "content": "LendingPoolCore",
              "key": "C"
            },
            {
              "content": "LendingPoolAddressesProviderRegistry",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f27e3567-22d4-441a-9b29-5e306dcff815",
          "type": "SingleChoice",
          "content": "Which contract can be used to obtain the most recent contract addresses?",
          "hint": "NoHint",
          "explanation": "LendingPoolAddressesProvideris the protocol's primary addresses register for specific marketplaces. The most recent contract addresses should be obtained from this contract by making the necessary calls.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "overview"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "LendingPoolAddressesProvider",
              "key": "A"
            },
            {
              "content": "LendingPool",
              "key": "B"
            },
            {
              "content": "LendingPoolCore",
              "key": "C"
            },
            {
              "content": "LendingPoolAddressesProviderRegistry",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "09ef1435-b99e-457d-bb95-b8f493d6b14e",
          "type": "SingleChoice",
          "content": "Which of the following methods is not included in the LendingPool contract?",
          "hint": "NoHint",
          "explanation": "Most interactions with Aave will happen via the LendingPool, including deposit(), borrow(), repay(), swapBorrowRateMode(), setUserUseReserveAsCollateral(), withdraw(), flashloan(), liquidationCall().",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "overview"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "deposit()",
              "key": "A"
            },
            {
              "content": "borrow()",
              "key": "B"
            },
            {
              "content": "withdraw()",
              "key": "C"
            },
            {
              "content": "scaledTotalSupply()",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7c7535a8-942c-4d6f-a49c-ecbbb587f175",
          "type": "SingleChoice",
          "content": "Despite all of the new features added in v3, the overall gas cost of all functions fell. By what percentage did the gas cost fall?",
          "hint": "NoHint",
          "explanation": "explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "versions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The overall gas cost of all functions fell by about 50%",
              "key": "A"
            },
            {
              "content": "The overall gas cost of all functions fell by about 25%",
              "key": "B"
            },
            {
              "content": "The overall gas cost of all functions fell by about 2.5%",
              "key": "C"
            },
            {
              "content": "The overall gas cost of all functions fell by about 5%",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "aadd93bd-8e38-4969-9f4d-ecbc5f2f3802",
          "type": "SingleChoice",
          "content": "Can any individual lend and borrow simultaneously via Aave?",
          "hint": "NoHint",
          "explanation": "An individual can lend and borrow simultaneously via Aave. The participants lending the tokens get interest on their loan and the participants borrowing the tokens pay interest.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "aave-smart-contracts-intro"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Yes, any individual lend and borrow simultaneously via Aave",
              "key": "A"
            },
            {
              "content": "No, any individual can not lend and borrow simultaneously via Aave",
              "key": "B"
            },
            {
              "content": "Only possible when the price of the collateral drops below the liquidation threshold",
              "key": "C"
            },
            {
              "content": "Only possible when the price of the collateral rises above the liquidation threshold",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "13dc4af8-4bac-44d8-8977-26a93135de9c",
          "type": "SingleChoice",
          "content": "What happens when the Health Factor falls below one?",
          "hint": "NoHint",
          "explanation": "Health factor is the ratio of total collateral multiplied by the liquidation threshold to borrowed principal. When the Health Factor falls below one, the loan is considered undercollateralized and can be liquidated.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "terminology"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The loan is considered overcollateralized and can be liquidated.",
              "key": "A"
            },
            {
              "content": "The loan is considered undercollateralized and can not be liquidated.",
              "key": "B"
            },
            {
              "content": "The loan is considered undercollateralized and can be liquidated.",
              "key": "C"
            },
            {
              "content": "The loan is considered overcollateralized and can not be liquidated.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2100e607-e07e-4c5b-a2b6-44301d59363e",
          "type": "SingleChoice",
          "content": "What is the ratio in which aTokens can be redeemed for the underlying token?",
          "hint": "NoHint",
          "explanation": "aTokens can be redeemed for the underlying token in a 1:1 ratio",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "functions-1"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "aTokens can be redeemed for the underlying token in a 1:10 ratio",
              "key": "A"
            },
            {
              "content": "aTokens can be redeemed for the underlying token in a 11:1 ratio",
              "key": "B"
            },
            {
              "content": "aTokens can be redeemed for the underlying token in a 1:1 ratio",
              "key": "C"
            },
            {
              "content": "aTokens can be redeemed for the underlying token in a 1:11 ratio",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d97848fc-cec7-4ce4-b39f-694fc565ca65",
          "type": "MultipleChoice",
          "content": "Pick the correct option(s).",
          "hint": "NoHint",
          "explanation": "Because the protocol does not employ an EIP-20 wrapper like wETH for ETH deposits, the deposit() method's amount parameter must match the transaction's msg.value parameter and be included in your deposit() call.",
          "answerKeys": [
            "A",
            "c"
          ],
          "subTopics": [
            "functions-1"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "AAVE protocol does not employ an EIP-20 wrapper",
              "key": "A"
            },
            {
              "content": "AAVE protocol employs an EIP-20 wrapper",
              "key": "B"
            },
            {
              "content": "The deposit() method's amount parameter must match the transaction's msg.value parameter",
              "key": "C"
            },
            {
              "content": "The deposit() method's amount parameter may or may not match the transaction's msg.value parameter",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "82214e78-253d-4fbc-bb56-fcd4dd805de8",
          "type": "SingleChoice",
          "content": "Which method allows the user's deposit to be used as collateral?",
          "hint": "NoHint",
          "explanation": "setUserUseReserveAsCollateral() allows the user's deposit to be used as collateral. Users will only be able to disable deposits that are not being used as collateral at the time.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "functions-1"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "deposit()",
              "key": "A"
            },
            {
              "content": "setUserUseDepositAsCollateral()",
              "key": "B"
            },
            {
              "content": "setUserReserveAsCollateral()",
              "key": "C"
            },
            {
              "content": "setUserUseReserveAsCollateral()",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f8891660-96d9-4b5c-94fb-5d9c611815ee",
          "type": "MultipleChoice",
          "content": "Which of the following statements about the repay() method is/are correct?",
          "hint": "NoHint",
          "explanation": "repay() method is used to repay a borrowed asset in whole or in part. The _onBehalfOf parameter can be used to repay a different user's debt. When a third-party repays another user's debt on their behalf, the third-party address must approve() the LendingPoolCore contract (which is separate from the LendingPool contract) with the _amount of the underlying ERC20 of the _reserve contract.",
          "answerKeys": [
            "B",
            "C"
          ],
          "subTopics": [
            "functions-2"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A borrowed asset has to be repaid in whole",
              "key": "A"
            },
            {
              "content": "A borrowed asset can be repaid in whole or in part",
              "key": "B"
            },
            {
              "content": "A third-party can repay another user's debt on their behalf",
              "key": "C"
            },
            {
              "content": "A third-party can not repay another user's debt on their behalf",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7c65668d-8b7b-4de9-8bd9-33736175bb18",
          "type": "SingleChoice",
          "content": "Which method changes the borrow rate modes of the msg.sender from stable to variable?",
          "hint": "NoHint",
          "explanation": "swapBorrowRateMode() changes the borrow rate modes of the msg.sender from stable to variable. rebalanceStableBorrowRate() rebalances the stable rate of _user",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "functions-2"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "rebalanceStableBorrowRate()",
              "key": "A"
            },
            {
              "content": "rebalanceBorrowRateMode()",
              "key": "B"
            },
            {
              "content": "swapStableBorrowRate()",
              "key": "C"
            },
            {
              "content": "swapBorrowRateMode()",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ecad25a7-bbdf-47cf-a062-325e8624ace5",
          "type": "SingleChoice",
          "content": "What happens when a liquidation is completed successfully?",
          "hint": "NoHint",
          "explanation": "When the liquidation is completed successfully, the position's health factor is enhanced, bringing it above 1. It does not affect the close factor.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "functions-2"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The position's health factor is enhanced, bringing it above 1",
              "key": "A"
            },
            {
              "content": "The position's health factor is diminished, bringing it below 1",
              "key": "B"
            },
            {
              "content": "The close factor is enhanced, bringing it above 1",
              "key": "C"
            },
            {
              "content": "The close factor is diminished, bringing it below 1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "48ffb9d9-108c-41e3-9a05-632b49b71d9b",
          "type": "MultipleChoice",
          "content": "What is the close factor?",
          "hint": "NoHint",
          "explanation": "A close factor determines how much collateral a liquidator can close. The current close factor is 0.5. In other words, liquidators can only liquidate up to 50% of the amount owing in a position. This is the amount of the liquidation discount.",
          "answerKeys": [
            "C",
            "D"
          ],
          "subTopics": [
            "functions-2"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The ratio of total collateral multiplied by the liquidation threshold to borrowed principal",
              "key": "A"
            },
            {
              "content": "The maximum borrowing capacity of a particular collateral",
              "key": "B"
            },
            {
              "content": "Determines how much collateral a liquidator can close",
              "key": "C"
            },
            {
              "content": "It is the amount of the liquidation discount",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "26144fd7-a1ae-44c4-b70f-dc6cc578ea87",
          "type": "SingleChoice",
          "content": "What value of the purchaseAmount parameter can be set to proceed with the largest liquidation allowed by the close factor?",
          "hint": "NoHint",
          "explanation": "purchaseAmount parameter can be set to uint(-1) and the protocol will proceed with the largest liquidation allowed by the close factor.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "functions-2"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "uint(1)",
              "key": "A"
            },
            {
              "content": "uint(-1)",
              "key": "B"
            },
            {
              "content": "uint(10)",
              "key": "C"
            },
            {
              "content": "uint(-10)",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f355a01c-c3d1-41f3-9685-c65d64b16926",
          "type": "MultipleChoice",
          "content": "Select the correct statement(s) about Flash loans.",
          "hint": "NoHint",
          "explanation": "Flash Loans are special transactions that allow you to borrow an asset as long as the borrowed amount (plus a fee) is returned before the transaction ends (also called One Block Borrows). These transactions do not necessitate the provision of collateral by the user prior to the transaction.",
          "answerKeys": [
            "A",
            "B"
          ],
          "subTopics": [],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "key": "A",
              "content": "Flash loans are also called One Block Borrows"
            },
            {
              "key": "B",
              "content": "Borrowed amount has to be returned in the same transaction"
            },
            {
              "key": "C",
              "content": "There is no need to pay fees"
            },
            {
              "key": "D",
              "content": "User has to provide collateral prior to the transaction"
            }
          ]
        },
        {
          "uuid": "c535ee8a-5ac8-47bf-8404-30138aae06f6",
          "type": "SingleChoice",
          "content": "Which of the following is the fee received by LP?",
          "hint": "NoHint",
          "explanation": "Fee to LP = FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL, Fee to Protocol = FLASHLOAN_PREMIUM_TO_PROTOCOL",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "functions-3"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "FLASHLOAN_PREMIUM_TO_PROTOCOL",
              "key": "A"
            },
            {
              "content": "FLASHLOAN_PREMIUM_TOTAL",
              "key": "B"
            },
            {
              "content": "FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL",
              "key": "C"
            },
            {
              "content": "FLASHLOAN_PREMIUM_TOTAL + FLASHLOAN_PREMIUM_TO_PROTOCOL",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "7441eb5f-68f3-40de-b12f-80dc17c80b2c",
          "shortTitle": "V2 Contracts",
          "details": "This video enables learners to know about\n  * AAVE\n  * Main protocol features\n  * What's new in v2 protocol\n  * Resources\n",
          "title": "Introduction to AAVE V2 Smart Contracts",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=AMAMvKc-O2s",
          "subTopics": []
        },
        {
          "uuid": "8b2485fe-7a9b-4dee-9e65-348c1dc7a66c",
          "shortTitle": "V3 contracts",
          "details": "This video enables learners to know about\n  * AAVE v3 features\n  * Build on top of AAVE\n",
          "title": "Introduction to AAVE V3 Smart Contracts",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=LzaS8IiqnPY",
          "subTopics": []
        }
      ],
      "summaries": [
        {
          "title": "Introduction",
          "shortTitle": "Introduction",
          "key": "aave-smart-contracts-intro",
          "details": "* Aave is a decentralized finance protocol that facilitates lending and borrowing of cryptocurrency tokens usAave ing diverse algorithms and smart contracts without the presence of centralized intermediaries. \n* It is a non-custodial liquidity protocol that allows users to participate as depositors or borrowers. Depositors provide liquidity to the market to earn a passive income, while borrowers are able to borrow in an overcollateralized manner.\n* The participants lending the tokens get interest on their loan and the participants borrowing the tokens pay interest. \n* An individual can lend and borrow simultaneously via Aave.\n* The working mechanism of Aave involves allocating a platform specific token, called aTokens to a user's crypto investment. This is what lenders get when they deposit their assets into the pool.\n* For instance, a user who deposits Ethereum in Aave will hold aETH on Aave. \n* aToken is based on a particular crypto asset and the interest rate each aToken earns is specific to the token deposited, depending on the supply and demand for the original coin.\n\n* Aave has a smart contract based working mechanism wherein the interest rates are determined by different algorithms.\n* The depositors lend the funds in the liquidity pools and earn interest, similarly borrowers can borrow the funds from the liquidity pools. \n* The interest rate for both borrowers and lenders is decided algorithmically:\n* **Interest rate for Borrowers**: The interest rate to be paid by the borrowers depends on the cost of money and the amount of funds available in the pool at a specific time.The amount of funds present in the pool has an inverse relationship with the interest rate. As funds are borrowed from the pool, the amount of funds available decreases which raises the interest rate. \n* **Interest rate for Lenders**: The interest rate received by the lenders corresponds to the earn rate, with the algorithm safeguarding a liquidity reserve to guarantee withdrawals at any time.\n\n* Since cryptocurrency is highly volatile, borrowing in Aave demands overcollateralization. \n* A liquidation event happens when the price of the collateral drops below the liquidation threshold.\n"
        },
        {
          "title": "Important Tech Terms",
          "shortTitle": "Tech Terms",
          "key": "terminology",
          "details": "* **APY**: Annual Percentage Yield is the yield/interest after a year, including compounding interest. This differs from the Annual Percentage Rate (APR), which does not account for compounding effects.\n\n* **Liquidity Index**: The reserve's interest accumulation during the time span since the last updated timestamp.\n\n* **Loan To Value**: The maximum borrowing capacity of a particular collateral. If a collateral has a Loan to Value of 75%, the user will be allowed to borrow 0.75 ETH of primary currency for every 1 ETH of collateral. The Loan To Value is represented in percentage points and is set per collateral.\n\n* **Liquidation Threshold**: The amount of a borrow position that must be liquidated because it is undercollateralized. When a collateral has an 80% liquidation threshold, it signifies that the loan will be liquidated when the debt value equals 80% of the collateral value. The liquidation threshold is defined in percentage points and is specified per collateral.\n\n* **Liquidation Bonus**: The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor less than one. The Liquidation Bonus is defined in percentage points and is determined per collateral.\n\n* **Health factor**: The ratio of total collateral multiplied by the liquidation threshold to borrowed principal. When the Health Factor falls below one, the loan is considered undercollateralized and can be liquidated.\n\n* **Stable rate**: A loan with a stable rate behaves like a fixed rate loan in the short term, but the rates can be rebalanced in the medium/long term in response to rapid market movements.\n\n* **Reserve** : Reserves are the underlying assets' ERC-20 contracts.\n"
        },
        {
          "title": "Released Versions",
          "shortTitle": "Versions",
          "key": "versions",
          "details": "* Aave has released three versions (v1, v2 and v3) as of now and the Governance token of Aave is \"AAVE\". Version 1 or v1 is the base version launched in 2017 and then there have been upgrades with multiple new features added. \n* Aave v2 improves on many areas of v1. Some of the changes are:\n  - There is no longer a LendingPoolCore contract in Aave v2 that retains all of the protocol's assets. Assets are held directly in the linked aToken contracts, with the LendingPool contract serving as the protocol's \"core.\"\n  - Almost all actions in Aave v2 should be executed via the LendingPool contract. This differs from v1, when a redemption/withdrawal of aTokens required a call on the aToken contract.\n  - After depositing collateral into the protocol, a user can easily delegate credit to any address by using approveDelegation() on the relevant debt token.\n  - Flash loans are possible inside the Aave v2 protocol. Indeed, they are widely utilised within the protocol for position switching and other 'trading'-like functions.\n  - Flash loans can now be executed in batches, which means that many flash loans with varied parameters can be performed in the same call. This opens the door to strong new use cases, such as repaying numerous assets and positions with a single flash loan transaction.\n  - You can now do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt (i.e. the flash loan is not paid back immediately).\n  - AddressesProviders will be numerous in multiple markets. The AddressesProviderRegistry will keep track of all Aave market address providers.\n  - LendingPoolCore has been decommissioned. Only LendingPool is used, which simplifies integrations and Aave v2 development.\n* The v3 improved features enable new use cases, sparking a flood of innovation from users and developers. Aave V3 generates I mprovements in all of the these areas - capital efficiency, security, decentralisation, and UX - while simultaneously delivering new functions to harness the capabilities of rollups and the developing ecosystem of rival L1s.\n  - Portal is a new set of core functionalities that can be utilised to enable provided assets to move easily between Aave markets on different networks. On the surface, the feature is fairly simple: the protocol uses the aTokens' unique pegged design to burn aTokens on the source network while minting them on the destination network.\n  - Borrowers can use High Efficiency Mode (E-Mode) to get the most borrowing power out of their collateral. Borrowers can use E-Mode to limit their borrowing to only assets in a specific category (e.g., stablecoins).\n  - One of the most important areas for improvement is managing the inherent complexities of risk exposure modulation.\n  - Repay with aTokens: Allows borrowers to repay with aTokens rather than the underlying asset.\n  - Despite all of the new features, the overall gas cost of all functions fell by about 25%.\n  - Smart contract re-engineering has considerably reduced code size (leaving more room for future revisions) by up to 100K optimizer runs!\n  - All token transfer functions (supply, repay) now support EIP 2612 authorization (this is especially important for L2).\n  - Signature on EIP 712 for credit delegation (no need for contracts to request a user transaction anymore).\n"
        },
        {
          "title": "Protocol Overview",
          "shortTitle": "Overview",
          "key": "overview",
          "details": "* Below image provides an overview of the protocol.\n\n![Architecture](https://github.com/DoDAO-io/dodao-aave-developer-1-course/blob/6bd13f67bbb027bc58280c103f78b0b29d5ad810/images/architechture.png?raw=true)\n`Reference: https://docs.aave.com/developers/v/2.0/the-core-protocol/protocol-overview`\n\n* On Github, the Aave Protocol repository can be found here: https://github.com/aave/\n\n#### Main Contracts\nThe main contracts in Aave and their purposes are:\n* LendingPool: The main entry point into the Aave Protocol. Most interactions with Aave will happen via the LendingPool, including:\n  - deposit()\n  - borrow()\n  - repay()\n  - swapBorrowRateMode()\n  - setUserUseReserveAsCollateral()\n  - withdraw()\n  - flashloan()\n  - liquidationCall()\n* LendingPoolAddressesProvider: The protocol's primary addresses register for specific marketplaces. The most recent contract addresses should be obtained from this contract by making the necessary calls.\n* LendingPoolAddressesProviderRegistry: Contains a list of active LendingPoolAddressesProvider addresses, for different markets.\n* aTokens: The yield-producing, tokenized deposits that are used throughout the Aave protocol. They implement, with minor modifications, the majority of the standard EIP-20/ERC20 token methods, as well as Aave-specific methods such as:\n  - scaledBalanceOf()\n  - getScaledUserBalanceAndSupply()\n  - scaledTotalSupply()\n  All aTokens also implement EIP-2612, which via the permit() function enables gas-less transfers and single transaction approve + actions.\n* Stable and Variable Debt Tokens: The Aave protocol employs tokenised borrow locations throughout. Because debt tokens are non-transferable, most common EIP-20/ERC20 techniques are disabled.\n"
        },
        {
          "title": "AAVE Functionalities in Details - I",
          "shortTitle": "Functions - I",
          "key": "functions-1",
          "details": "* The LendingPool contract is the protocol's principal contract. It exposes all user-oriented operations that may be performed with the Solidity or web3 libraries. The source code is available [here](https://github.com/aave/aave-protocol/blob/master/contracts/lendingpool/LendingPool.sol).\n\n#### Deposit/Lending\n* Lenders share the interest payments made by borrowers based on the utilization rate multiplied by the average borrowing rate. The yield for depositors increases as reserve utilization increases.\n* Lenders are also entitled to a portion of the Flash Loan fees, equal to 0.09% of the Flash Loan volume.\n* There is no minimum or maximum deposit amount; you may deposit any amount you choose.\n\n#### Methods\n#### deposit()\n**function deposit( address _reserve, uint256 _amount, uint16 _referralCode)**\n* Deposits a certain _amount of an asset specified by the _reserve parameter.\n* In exchange, the caller receives a specific number of aTokens. aTokens can be redeemed for the underlying token in a 1:1 ratio.\n* When depositing an ERC-20 token, the LendingPoolCore contract (not the LendingPool contract) must have the required allowance of _amount for the underlying ERC20 of the _reserve asset via approve().\n\n**ETH deposits**\n* Because the protocol does not employ an EIP-20 wrapper like wETH for ETH deposits, the deposit() method's amount parameter must match the transaction's msg.value parameter and be included in your deposit() call.\n* E.g: lendingPool.deposit{ value: msg.value }(reserve, msg.value, referralCode)\n* Because ETH is utilised directly in the protocol (rather than an abstraction like WETH), we use a dummy address to represent it: 0xEeeeeEeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n\n**ERC20 deposits**\n* The _reserve parameter corresponds to the underlying asset's ERC20 contract address.\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L753\n\n* The deposit() flow within the protocol is available [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH4HvCIm09jkjFv%2Flending%20pool%20deposit.png?alt=media&token=c92f8256-9d73-41a1-9e96-a3d807425d08)\n \n#### setUserUseReserveAsCollateral()\n**function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral)**\n* Allow the user's deposit to be used as collateral. Users will only be able to disable deposits that are not being used as collateral at the time.\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L341 \n\n**Stable vs Variable Interest Rate**\n* In the short-term, stable rates function as a fixed rate, but they can be rebalanced in the long run in reaction to alterations in the market environment. \n* Depending on supply and demand in Aave, the variable rate can change.\n* The stable rate is the better choice for forecasting how much interest you will have to pay because, as its name suggests, it will remain fairly stable. The variable rate changes over time and, depending on market conditions, could be the optimal rate.\n"
        },
        {
          "title": "AAVE Functionalities in Details - II",
          "shortTitle": "Functions - II",
          "key": "functions-2",
          "details": "#### Borrow\n* You must deposit any asset to be used as collateral before borrowing.The amount you can borrow depends on the value you have deposited and the readily available liquidity.For instance, if there isn't enough liquidity or if your health factor (minimum threshold of the collateral = 1, below this value, liquidation of your collateral is triggered) prevents it, you can’t borrow an asset. The loan is repaid with the same asset that you borrowed.\n* For instance, if you borrow 1 ETH, you'll need to pay back 1 ETH plus interest.\n* In the updated Version 2 of the Aave Protocol, you can also use your collateral to make payments. You can borrow any of the stablecoins like USDC, DAI, USDT, etc. if you want to repay the loan based on the price of the USD.\n\n#### Methods\n#### borrow()\n**function borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode)** \n* Transfers a certain amount of the asset identified by the _reserve parameter to the msg.sender, provided the caller has deposited enough collateral to fund the borrow in advance.\n* Every loan can be opened in either a fixed or variable rate mode. Borrows have an indefinite term and no payback date. In the event of market swings, a borrow position is liquidated if the collateral price falls below a specific threshold. Please read the White Paper to learn more about the stable rate economy.\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L219 \n\n* The borrow() flow within the protocol is available [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH3GOEvYvbizwHC%2Flending%20pool%20borrow.png?alt=media&token=2031b536-733e-4a8a-866c-23c86706e641)\n\n#### repay()\n**function repay( address _reserve, uint256 _amount, address payable _onBehalfOf)**\n* Repay a borrowed asset in whole or in part. The _onBehalfOf parameter can be used to repay a different user's debt.\n* When a third-party repays another user's debt on their behalf, the third-party address must approve() the LendingPoolCore contract (which is separate from the LendingPool contract) with the _amount of the underlying ERC20 of the _reserve contract.\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L249 \n\n* The repay() flow within the protocol is available [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH9NighH7i_73lI%2Flending%20pool%20repay.png?alt=media&token=cb6e102e-222b-412a-92f0-763ae34e7cce) \n \n#### swapBorrowRateMode()\n**function swapBorrowRateMode(address _reserve)**\n* Changes the borrow rate modes of the msg.sender from stable to variable.\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L326 \n\n#### rebalanceStableBorrowRate()\n**function rebalanceStableBorrowRate(address _reserve, address _user)**\n* Rebalances the stable rate of _user\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L336 \n\n* The rebalance flow for stable rates in the protocol is available [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH7rY4WFE5jRwrB%2Flending%20pool%20rebalancing.png?alt=media&token=8a442d62-6087-4adf-b27b-163478547f79)  \n\n#### liquidationCall()\n**function liquidationCall(address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveaToken)**\n* Positions with a health factor less than one should be liquidated.\n* When a position's health factor falls below one, liquidators repay part or all of the outstanding borrowed amount on behalf of the borrower in exchange for a discounted quantity of collateral (sometimes known as a liquidation \"bonus\"). \n* Liquidators have the option of receiving an equal quantity of collateral aTokens or the underlying asset directly. \n* When the liquidation is completed successfully, the position's health factor is enhanced, bringing it above 1.\n* A close factor determines how much collateral a liquidator can close. The current close factor is 0.5. In other words, liquidators can only liquidate up to 50% of the amount owing in a position. This is the amount of the liquidation discount.\n* Liquidators must approve() the LendingPoolCore contract (which is distinct from the LendingPool contract) in order to use the underlying ERC20 of the _reserve asset for the liquidation.\n* **NOTE**: In most cases, profitable liquidators will choose to liquidate as much of the _user position as possible.\n* purchaseAmount parameter can be set to uint(-1) and the protocol will proceed with the largest liquidation allowed by the close factor.\n* For ETH liquidations, the transaction's msg.value should be identical to the _purchaseAmount parameter.\n* To determine a user's health factor, use getUserAccountData().\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L360 \n\n* The liquidation flow in the protocol is available [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH6dX0q9LDXBn9X%2Flending%20pool%20liquidation.png?alt=media&token=6701e381-1fd1-42ce-919b-39da57434c57)\n"
        },
        {
          "title": "AAVE Functionalities in Details - III",
          "shortTitle": "Functions - III",
          "key": "functions-3",
          "details": "* Flash Loans are special transactions that allow you to borrow an asset as long as the borrowed amount (plus a fee) is returned before the transaction ends (also called One Block Borrows). \n* These transactions do not necessitate the provision of collateral by the user prior to the transaction.\n* To use this feature, you must have a solid understanding of EVM, programming, and smart contracts. To do a Flash Loan, you must first create a contract requesting a Flash Loan. The contract must follow the instructions and repay the loan plus interest and fees in the same transaction.\n\n* Aave v3 provides two flash loan options:\n  - **flashLoan**: Allows the borrower to obtain liquidity from various reserves in a single flashLoan transaction. In this instance, the borrower has the option of opening a stable or variable rate debt position backed by supplied collateral or credit delegation.\n  - **NOTE**: For qualified flashBorrowers, the loan charge is waived (managed by ACLManager)\n  - **flashLoanSimple**: Allows the borrower to access a single reserve of liquidity for the transaction. In this situation, the flash loan fee is not waived, and the borrower is not permitted to open any debt positions at the conclusion of the transaction. For individuals attempting to take advantage of a simple flash loan with a single reserve asset, this strategy is gas efficient.\n\n#### Flow of Execution\n* A helpful mental model to consider when creating your solution for developers:\n  - Your contract contacts the Pool contract and requests a Flash Loan for a specific amount(s) of reserve(s) using flashLoanSimple() or flashLoan() ().\n  - The Pool sends the requested amounts of reserves to your contract after some sanity checks, then executes executeOperation() on the receiver contract.\n  - Your contract now does any arbitrary operation in its code while holding the flash borrowed amount(s).\n  - When you finish your code for a flashLoanSimple, you approve Pool for the flash loaned amount + charge.\n  - If you are executing flashLoan, then all reserves must be granted for flash borrowed amount + fee or adequate collateral or credit delegation must be provided to start debt position, based on the interestRateMode passed for the asset.\n  - If the amount owed is not available (due to a lack of balance or authorisation, or insufficient debt collateral), the transaction is reverted.\n  - All of the preceding occurs in a single transaction (hence in a single ethereum block).\n\n#### Flash Loan Applications\n* Aave Flash Loans are already used for the liquidity swap functionality in Aave V3. Other real-world instances include: arbitrage between assets without requiring the main amount to be present.\n* Liquidating borrow positions without having to repay the debt of the positions and paying off flashLoan amount + charge with discounted collateral claimed.\n\n#### Fee for a Flash loan\n* The flash loan charge is set to 0.09% at deployment and can be changed via Governance Vote. To obtain the current value, use FLASHLOAN PREMIUM TOTAL.\n* The LPs (liquidity providers) and the protocol treasury can split the flashloan charge. The FLASHLOAN PREMIUM TOTAL variable represents the total charge paid by borrowers, which includes:\n* Fee to LP: FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL\n* Fee to Protocol: FLASHLOAN_PREMIUM_TO_PROTOCOL\n* At initialization, FLASHLOAN_PREMIUM_TO_PROTOCOL is 0.\n\n#### First step: Setting Up\n* By implementing the relevant executeOperation() function, your contract that receives the amounts from flash loans must comply with the IFlashLoanSimpleReceiver.sol or IFlashLoanReceiver.sol interface.\n* Additionally, keep in mind that since the owing sums will be deducted from your contract, your contract must let the Pool to deduct those monies in order to repay the flash loan amount plus premiums.\n\n#### Second Step: Calling flashLoan() or flashLoanSimple()\n* To invoke either of the Pool's two flash lending methods, we must provide the necessary parameters. There are three possibilities.\n  - From an EOA ('normal' Ethereum account)\n    - To use an EOA, send a transaction to the appropriate Pool and use the flashLoan() or flashLoanSimple() functions. For parameter information, see the Pool API documentation, making sure to use your contract address from step 1 for the receiverAddress.\n  - From a different contract\n    - As with transmitting a transaction from an EOA, make sure the receiverAddress matches your contract address from step 1.\n  - From the same contract\n    - Utilize address(this) for the receiverAddress parameter in the flash loan method if you wish to use the same contract as in step 1.\n* **Note**: Never keep funds permanently on your FlashLoanReceiverBase contract as they could be exposed to a ['griefing' attack](https://ethereum.stackexchange.com/a/92457/19365), where the stored funds are used by an attacker.\n\n#### Final Step: Completing the flash loan\n* If you used flashLoanSimple() or interestRateMode=0 in flashLoan() for any of the assets in the modes parameter, you will need to repay the flash loaned amounts once you have completed your logic with the flash loaned assets (in your executeOperation() method).\n  - Repaying a flash loaned asset\n    - Check that your contract includes the appropriate amount + premium to repay the borrowed asset. This can be calculated by adding the relevant entries in the amounts and premiums array given to the executeOperation() function. \\\n    - You are not required to return the owing sum to the Pool. The cash will be automatically withdrawn at the end of your operation.\n  - Getting into debt (i.e. not immediately paying back)\n    - If you used mode=1 or mode=2 for any of the assets in the modes parameter, the address put in for onBehalfOf will incur the obligation if the onBehalfOf address previously authorised the msg.sender to incur debts on their behalf.\n    - This means that you can have some assets that are promptly paid back while others incur debt.\n"
        }
      ]
    },
    {
      "title": "Fetch and Show AAVE Data",
      "key": "fetching-aave-data",
      "details": "This chapter taks about how you can fetch real time and time series data from AAVE and show it on the UI.\n",
      "order": 1,
      "explanations": [
        {
          "title": "Introduction",
          "shortTitle": "Introduction",
          "key": "aave-data-intro",
          "details": "AAVE is a DeFi protocol that facilitates the lending and borrowing of cryptocurrency tokens using diverse algorithms and smart contracts without centralized intermediaries. \nIt is a non-custodial liquidity protocol that allows users to participate as lenders or borrowers. Depositors provide liquidity to the market to earn a passive income, while borrowers are able to borrow in an overcollateralized manner.\nAave's GraphQL data layer is a great resource for developers, allowing developers to access data that may not have been available otherwise. This way developers can work with more data and create more advanced applications. \nJust like any decentralized blockchain application, Aave's data can be classified into three types: \n- **Real-time data or current information** - This includes the current state and the new events. With real-time data, you can use data visualisations that reflect changes as they occur in real-time. This means that dashboards are interactive and accurate at any given moment.\n- **Historical** - This includes past state and events. With historical data, you can get a snapshot of information displayed in a chart.\n\nAs discussed above, there are multiple use cases of this data provided by Aave and varied applications (including read-only as well as read/write applications) can be built on top of it and we can examine this data to gain insights on how to update and continue to improve the application.\n\nThe focus of this chapter will be to use Aave's data and show it on the UI in a couple of use cases. \n- Creating a pie graph to review the aave treasury in USDT \n- Implementing a time series graph of how the holdings of different pools have changed over time.\n\nBefore moving on to the code, let's have a look at the importance of analytics.\n\n**Importance of Analytics**\n- Make informed decisions\n- Improve efficiency\n- Identify frauds\n- Improve protocol governance\n- Accelerate through uncertainty\n- Tackle bugs and problems\n- Transform raw data into more valuable information\n\nAave's data can be queried in the form of REST or GraphQL. Aave uses “The Graph” to index its data and anyone can query the subgraphs to get access to this information.\n"
        },
        {
          "key": "graphql",
          "title": "Realtime GraphQL Data",
          "shortTitle": "GraphQL",
          "details": "#### The Graph and GraphQL\nThe Graph is a decentralized protocol for indexing and querying data from Ethereum-based blockchains. That is, obtaining specific data from the blockchain is a more convenient approach while adhering to the web3 ethos and benefiting from decentralization and stability.\n\nThe underlying query language used in The Graph is GraphQL. What is the distinction between RESTFUL API calls and GraphQL calls? Traditional APIs, on the other hand, require developers to define unique endpoints for users that return specified data. If the user requires further information, they may need to make repeated API calls, potentially hundreds of API calls, to obtain it. As long as the developer has established a flexible schema, The Graph (which uses GraphQL) just requires one call to a subgraph.\nSee this [GraphQL primer](https://medium.com/graphprotocol/graphql-will-power-the-decentralized-web-d7443a69c69a) for additional information on The Graph and the underlying GraphQL.\n\n#### Source of Aave Subgraphs\nTo view the source of the subgraphs, see our [Github repo](https://github.com/aave/protocol-v2-subgraph).\n\nProduction Network: [Polygon](https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-polygon)\n\n#### How to Make Use of the Playground\n\n- If you use your browser to navigate to the above playground links, you will be directed to The Graph's playground, where you can simply write and test GraphQL queries.\n- Select the purple play button to run your query.\n- In the middle column, the query results will be returned.\n- Use the 'Schema' column on the right to see what data is available, which may be investigated to discover the underlying data.\n- You can also type in the left column and use the auto-complete feature to identify the appropriate query/types.\n\n#### Points to keep in mind\n- All address values (for example, when used for id) must be in lowercase.\n- In lowercase, the ID of reserves is the asset's address and the address of the market's LendingPoolAddressProvider.\n- When utilizing the raw endpoints, the numeric number queried will be returned in either wei units (i.e. 10^18), the decimals of the asset itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).\n- By default, each 'page' of results returns 100 entries. This is expandable to a maximum of 1000 entries per page.\n- To list the following 1000 entries, for example, put something like: (skip:1000, first: 1000) to your query's arguments.\n- This is also true for nested entries, such as arrays.\n\nThis Graph endpoint contains only static data. To obtain a user's most recent balance (including interest earned up to that moment), you must either compute it yourself or make a balanceOf() call to the aToken contract.\n\n| Return Data Type           | Subgraph Address                                                       |\n| -------------------------- | ---------------------------------------------------------------------- | \n| Mainnet                    | https://thegraph.com/explorer/subgraph/aave/aave-v2-matic              |\n| Görli (Goerli) Testnet     | https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-goerli   |\n\nGoerli is an Ethereum test network that allows blockchain development testing prior to deployment on the main Ethereum network, Mainnet. Görli (Goerli) Testnet is the first proof-of-authority cross-client testnet, synching Parity Ethereum, Geth, Nethermind, Hyperledger Besu (formerly Pantheon), and EthereumJS. This testnet is a community-based project, completely open-source, naturally. It was born in September 2018 during ETHBerlin and has been growing in contributors ever since.\n\n#### Using your app to access GraphQL data\n\nThe preferred method is to utilize a client library that can handle the 'plumbing' to ensure you have up-to-date data (with caching sometimes included). Apollo is used internally, but there are several choices depending on your programming language; read the official GraphQL page for more information.\nIf you are unable to utilize a client library (for example, while querying using Postman), you can send a POST request to our subgraph's HTTP endpoint with the header: \"Content-Type: application/json\" and the body comprising of your query on one line in quotations. As an example:\n```\n{\"query\": \"{ reserves (where: {usageAsCollateralEnabled: true})  { id name price {id} liquidityRate variableBorrowRate stableBorrowRate}}\" }\n```\n\n"
        },
        {
          "key": "historical-rest-data",
          "title": "Historical Rest Data",
          "shortTitle": "Historical Rest Data",
          "details": "Now we will use the [Aave Protocol API](https://aave-api-v2.aave.com/) to create a time series graph.\nWe will use the same react application to create the time series graph too, so if you still haven't create a react app by following the previous steps.\n\nSince the the [Aave Protocol API](https://aave-api-v2.aave.com/) is for v2 mainnet so now we need to query the Aave v2 mainnet subgraph.\n\nWe need to make the fetch requests from https://aave-api-v2.aave.com/#/data/get_data_rates_history to get the time series data for any Aave reserve. \nIf you visit the above link, you can see that we require a reserveID to fetch the data (there is a sample reserveID already provided in case you want to try it out). So to get this reserveID, we will query the Aave v2 mainnet subgraph (https://thegraph.com/hosted-service/subgraph/aave/protocol-v2 ). We have already queried the reserveIDs for ChainLink Token (0x514910771af9ca656af840dff83e8264ecf986ca0xb53c1a33016b2dc2ff3653530bff1848a515c8c5) and TrueUSD (0x0000000000085d4780b73119b644ae5ecd22b3760xb53c1a33016b2dc2ff3653530bff1848a515c8c5) which we will be using to plot the graph. \n\nIf you want to query the reserveID yourself, you can try this:\n```graphql\n{\n  pools {\n    reserves {\n      id\n      name\n      symbol\n    }\n  }\n}\n```\n\nThis query returns us an array of objects which contains the pools with the reserves id, name and symbol.\n\nAlso, in the GET request we need to provide the start date (from) and time interval (resolutionInHours) to fetch the data. You can use [this](https://www.epochconverter.com/) UNIX timestamp convertor to change the date.\nSo now you can visit the aave protocol api and playaround with different reserveID, from and resolutionInHours.\n\nNow, let's visit our App.js and add some changes to code to get our desired graph.\n\n* Let's add some import statements as we need to use Line Chart this time to represent the time series data. So you can update your import statements to the following:\n  ```javascript\n  import React, {useEffect, useState} from 'react';\n  import { useQuery, gql } from '@apollo/client';\n  import { Chart as ChartJS, ArcElement, Tooltip, Legend, CategoryScale, LinearScale, PointElement, LineElement, Title, } from 'chart.js';\n\n  import { Pie, Line } from 'react-chartjs-2';\n  import './App.css';\n\n  ChartJS.register(ArcElement, \n      CategoryScale,\n      LinearScale,\n      PointElement,\n      LineElement,\n      Title,\n      Tooltip,\n      Legend\n  );\n  ```\n\n* Now, we need to fetch the get requests so for that we will use the useEffect hook from React and store the data using useState hook. So add the following code to your DisplayGraphs functions:\n  ```javascript\n  const [linedata1, setLinedata1] = useState([]);\n      const [linedata2, setLinedata2] = useState([]);\n\n      useEffect(() => {\n          Promise.all([\n              fetch('https://aave-api-v2.aave.com/data/rates-history?reserveId=0x514910771af9ca656af840dff83e8264ecf986ca0xb53c1a33016b2dc2ff3653530bff1848a515c8c5&from=1667952000&resolutionInHours=6'),\n              fetch('https://aave-api-v2.aave.com/data/rates-history?reserveId=0x0000000000085d4780b73119b644ae5ecd22b3760xb53c1a33016b2dc2ff3653530bff1848a515c8c5&from=1667952000&resolutionInHours=6'),\n          ])\n          .then(([resData1, resData2]) => \n              Promise.all([resData1.json(), resData2.json()])\n          )\n          .then(([data1, data2]) => {\n              console.log(data1, data2);\n              setLinedata1(data1);\n              setLinedata2(data2);\n          })\n          .catch(([err1, err2]) => {\n              console.log(err1.message, err2.message);\n          });\n      }, []);\n  ```\n\n  The Get request also returns some unwanted data and the timestamp is in a format which we don't like much, so let's update it:\n  ```javascript\n  let timestamps = linedata1.map(a => (a.x.year + '/' + a.x.month + '/' + a.x.date + ' ' + a.x.hours + ' hours'));\n      let utilization1 = linedata1.map(a => a.utilizationRate_avg);\n      let utilization2 = linedata2.map(a => a.utilizationRate_avg);\n\n      timestamps.forEach((element, index) => {\n          timestamps[index] = element.toString();\n      });\n  ```\n* Now, let's create the Line chart using the following code:\n  ```javascript\n  const optionsLineChart = {\n          responsive: true,\n          plugins: {\n            legend: {\n              position: 'top',\n            },\n            title: {\n              display: true,\n              text: 'Avg Utilization Rate',\n            },\n          },\n      };\n        \n  const linedata = {\n      labels: timestamps,\n      datasets: [\n        {\n          label: 'ChainLink Token',\n          data: utilization1,\n          borderColor: 'rgb(255, 99, 132)',\n          backgroundColor: 'rgba(255, 99, 132, 0.5)',\n        },\n        {\n          label: 'TrueUSD',\n          data: utilization2,\n          borderColor: 'rgb(53, 162, 235)',\n          backgroundColor: 'rgba(53, 162, 235, 0.5)',\n        },\n      ],\n  };\n\n  return (\n      <div className=\"Chart-container\">\n          <div className=\"Pie-container\">\n              <Pie options={optionsPieChart} data={piedata} />\n          </div>\n          <div className=\"Line-container\">\n              <Line options={optionsLineChart} data={linedata} />\n          </div> \n      </div>\n  );\n  ```\n\nThis will provide us with the following time series graph:\n\nYou can get the complete code [here](https://github.com/DoDAO-io/aava-analytics-sample-app). \n"
        },
        {
          "key": "graphql-queries",
          "shortTitle": "Graphql Queries",
          "details": "\n#### Examples of Queries\n\nWe'll be using the mainnet Big uints GraphQL endpoints in the queries below. These queries can be copied and pasted into the Graph playground links.\n\n##### Reserve Data\nIf we want to receive a list of all the reserves that can be used as collateral, as well as the interest rates for each reserve, we can use the following query:\n```graphql\n{\n  reserves (where: {\n    usageAsCollateralEnabled: true\n  }) {\n    id\n    name\n    price {\n      id\n    }\n    liquidityRate\n    variableBorrowRate\n    stableBorrowRate\n  }\n}\n```\n\nWe would utilise the reserves ERC20 token address to retrieve data for a certain reserve. For the Chainlink reserve, for example:\n\n```graphql\n{\n  reserve(id: \"0x514910771af9ca656af840dff83e8264ecf986ca0x24a42fd28c976a61df5d00d0599c34c4f90748c8\") { // LINK\n    symbol\n    price\n    aToken {\n      id\n    }\n  }\n}\n```\n\nIf we wish to retrieve historical interest rate data for a specific reserve and paginate through the records, our query may look like this:\n```graphql\n{\n  reserve (id: \"0x0000000000085d4780b73119b644ae5ecd22b3760x24a42fd28c976a61df5d00d0599c34c4f90748c8\") { // TUSD\n    id\n    paramsHistory(skip:1000, first: 1000) {\n      id\n      variableBorrowRate\n      utilizationRate\n      liquidityRate\n      timestamp\n    }\n  }\n}\n```\n\n##### User Data\nWhen an address communicates with the Aave Protocol, a UserReserve is generated, with the user ID equal to the user's address plus the reserve's ID (which is the ERC20 token address).\nTo obtain information on a certain UserReserve:\n```graphql\n{\n  userReserve(id: \"USER_ADDRESS_AND_RESERVE_ADDRESS\") {\n    reserve {\n      id\n      symbol\n    }\n    user {\n      id\n    }\n  }\n}\n```\n\nTo retrieve all reserves (i.e. positions) held by a specific user (notice that the user address must be lower case):\n```graphql\n{\n  userReserves(where: { user: \"USER_ADDRESS\"}) {\n    id\n    reserve{\n      id\n      symbol\n    }\n    user {\n      id\n    }\n  }\n}\n```\n\n##### Deposit data\nTo obtain recent deposits for a certain asset:\n```graphql\n{\n  deposits (orderBy: timestamp, orderDirection: desc, where: { \n    reserve: \"0xdac17f958d2ee523a2206206994597c13d831ec70x24a42fd28c976a61df5d00d0599c34c4f90748c8\" // USDT\n  }) {\n    id\n    amount\n    timestamp\n  }\n}\n```\n\n##### Borrow data\nTo obtain recent borrows for a certain asset:\n```graphql\n{\n  borrows (orderBy: timestamp, orderDirection: desc, where: { \n    reserve: \"0xdac17f958d2ee523a2206206994597c13d831ec70x24a42fd28c976a61df5d00d0599c34c4f90748c8\" // USDT\n  }) {\n    id\n    amount\n    timestamp\n  }\n}\n```\n\n##### Flash loan data\nFor instance, consider the following query for analysing the five most recent Flash Loans:\n```graphql\n{ \n  flashLoans( \n    first: 5 \n    orderBy: timestamp \n    orderDirection: desc \n  ) { \n    id \n    reserve { \n      id \n      name \n      symbol \n    } \n    amount \n    totalFee \n    timestamp \n  } \n} \n```",
          "title": "Graphql Queries"
        },
        {
          "key": "react-app",
          "title": "Querying Aave's GraphQL database using React and implementing a Pie chart",
          "shortTitle": "React App",
          "details": "* **Initial Setup**\n  First, let's create a React project, you can refer [this](https://create-react-app.dev/docs/getting-started/) documentation.\n  ```\n  npx create-react-app aave-analytics-sample-app\n  ```\n  Run npm start to check if the project runs fine.\n\n* **Integrate ApolloClient**\n  Let's integrate the Apollo client library. We can install and setup the client using [this](https://www.apollographql.com/docs/react/get-started/) documentation.\n  ```shell\n  npm install @apollo/client graphql\n  ```\n  We can use the sample code to fetch the data and test our setup.\n\n* **Initialize the ApolloClient**\n  With our dependencies already set up, we can now create an ApolloClient instance.\n  Let's start by importing the symbols we require from @apollo/client into index.js:\n  ```javascript\n  import { ApolloClient, InMemoryCache, ApolloProvider, gql } from '@apollo/client';\n  ```\n  Next, we'll initialize ApolloClient by handing it a configuration object including the uri and cache fields:\n  ```javascript\n  const client = new ApolloClient({\n    uri: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-goerli',\n    cache: new InMemoryCache(),\n  });\n  ```\n\n* **Connect the client to React**\n  We can connect Apollo Client to React with the ApolloProvider component. Similar to React's Context.Provider, ApolloProvider wraps our React app and places Apollo Client on the context, enabling us to access it from anywhere in our component tree.\n\n  In index.js, let's wrap our React app with an ApolloProvider\n  ```javascript\n  import React from 'react';\n  import * as ReactDOM from 'react-dom/client';\n  import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';\n  import App from './App';\n\n  const client = new ApolloClient({\n    uri: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-goerli',\n    cache: new InMemoryCache(),\n  });\n\n  const root = ReactDOM.createRoot(document.getElementById('root'));\n\n  root.render(\n    <ApolloProvider client={client}>\n      <App />\n    </ApolloProvider>,\n  );\n  ```\n\n* **Fetching data with useQuery**\n  After the ApolloProvider is hooked up, we can start requesting data with useQuery. The useQuery hook is a React hook that shares GraphQL data with your UI.\n  Switching over to our App.js file, we'll start by replacing our existing file contents with the code snippet below:\n  ```javascript\n  import { useQuery, gql } from '@apollo/client';\n\n  export default function App() {\n  return (\n      <div className=\"App\">\n          <h2 className=\"App-header\">AAVE Analytics</h2>\n          <br/>\n          <DisplayGraphs />\n      </div>\n  );\n  }\n  ```\n  We can define the query we want to execute by wrapping it in the gql template literal:\n  ```graphql\n  const GET_QUERY = gql`\n  {\n      reserves {\n          id\n          symbol\n          name\n    \n          totalLiquidity\n      }\n  }\n  `;\n  ```\n  Next, let's define a component named DisplayGraphs that executes our GET_QUERY query with the useQuery hook:\n  ```javascript\n  function DisplayLocations() {\n    const { loading, error, data } = useQuery(GET_QUERY);\n\n    if (loading) return <p>Loading...</p>;\n    if (error) return <p>Error :(</p>;\n\n    let names = data.reserves.map(a => a.name);\n      let total = data.reserves.map(a => a.totalLiquidity);\n      let utilization = data.reserves.map(a => a.utilizationRate);\n\n      total.forEach((element, index) => {\n          total[index] = element % 10^18;\n      });\n  ….\n  }\n  ```\n\n* **Implementing the Pie Chart**\n  Now, our aim is to create a pie chart using the data we receive. So now we'll use [react-chartjs-2](https://react-chartjs-2.js.org/).\n  ```\n  npm install --save chart.js react-chartjs-2\n  ```\n  Then we will import it in our App.js:\n  ```\n  import { Pie } from 'react-chartjs-2';\n  ```\n  Now we need to initialize our code to get a Pie chart:\n  ```\n  ChartJS.register(ArcElement, Tooltip, Legend);\n  ```\n\n* Finally we will add the code to get our Pie chart:\n  ```javascript\n  const piedata = {\n          labels: names,\n          datasets: [\n            {\n              label: 'percentage',\n              data: total,\n              backgroundColor: [\n                'rgba(255, 99, 132, 0.2)',\n                'rgba(54, 162, 235, 0.2)',\n                'rgba(255, 206, 86, 0.2)',\n                'rgba(75, 192, 192, 0.2)',\n                'rgba(153, 102, 255, 0.2)',\n                'rgba(255, 159, 64, 0.2)',\n                'rgba(255, 140, 64, 0.2)',\n                'rgba(205, 159, 64, 0.2)',\n              ],\n              borderColor: [\n                'rgba(255, 99, 132, 1)',\n                'rgba(54, 162, 235, 1)',\n                'rgba(255, 206, 86, 1)',\n                'rgba(75, 192, 192, 1)',\n                'rgba(153, 102, 255, 1)',\n                'rgba(255, 159, 64, 1)',\n                'rgba(205, 159, 64, 1)',\n                'rgba(255, 149, 64, 1)',\n              ],\n              borderWidth: 1,\n            },\n          ],\n      };\n\n  const optionsPieChart = {\n          responsive: true,\n          plugins: {\n            legend: {\n              position: 'top',\n            },\n            title: {\n              display: true,\n              text: 'Total Liquidity',\n            },\n          },\n      };\n\n    return (\n          <div className=\"Chart-container\">\n              <div className=\"Pie-container\">\n                  <Pie options={optionsPieChart} data={piedata} />\n              </div>\n          </div>\n      );\n  ```\n\n  This will give us a Pie chart in our React app.\n\n  You can get the complete code [here](https://github.com/DoDAO-io/aava-analytics-sample-app).\n"
        }
      ],
      "questions": [
        {
          "uuid": "eca9d545-0c8a-42f8-8d45-5dfd675a4187",
          "type": "MultipleChoice",
          "content": "Which of the following points about AAVE is/are correct?",
          "hint": "NoHint",
          "explanation": "AAVE is a DeFi protocol that facilitates the lending and borrowing of cryptocurrency tokens using diverse algorithms and smart contracts without centralized intermediaries. It is a non-custodial liquidity protocol that allows users to participate as lenders or borrowers.",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "aave-data-intro"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "AAVE is a decentralized finance protocol",
              "key": "A"
            },
            {
              "content": "AAVE is a centralized finance protocol",
              "key": "B"
            },
            {
              "content": "AAVE is a non-custodial liquidity protocol",
              "key": "C"
            },
            {
              "content": "AAVE is a custodial liquidity protocol",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7e090787-7925-4eda-8acd-fb90dce8582e",
          "type": "MultipleChoice",
          "content": "Select the correct statement(s).",
          "hint": "NoHint",
          "explanation": "RESTFUL APIs require developers to define unique endpoints for users that return specified data. If the user requires further information, they may need to make repeated API calls, potentially hundreds of API calls, to obtain it. As long as the developer has established a flexible schema, The Graph (which uses GraphQL) just requires one call to a subgraph.",
          "answerKeys": [
            "A",
            "B",
            "D"
          ],
          "subTopics": [
            "graphql"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "RESTFUL APIs require developers to define unique endpoints for users that return specified data.",
              "key": "A"
            },
            {
              "content": "If the user requires further information, they may need to make repeated API calls",
              "key": "B"
            },
            {
              "content": "The Graph requires developers to define unique endpoints for users that return specified data.",
              "key": "C"
            },
            {
              "content": "The Graph just requires one call to a subgraph.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e2fb2ae0-dc82-454b-988e-ce59d450fe4a",
          "type": "SingleChoice",
          "content": "What is The Graph?",
          "hint": "NoHint",
          "explanation": "The Graph is a decentralized protocol for indexing and querying data from Ethereum-based blockchains.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "graphql"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Centralized protocol for indexing and querying data",
              "key": "A"
            },
            {
              "content": "Decentralized protocol for indexing and querying data",
              "key": "B"
            },
            {
              "content": "Decentralized query language",
              "key": "C"
            },
            {
              "content": "Centralized query language",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "053c742c-3992-42da-abac-719e4260b878",
          "type": "SingleChoice",
          "content": "What happens when an address communicates with the Aave Protocol?",
          "hint": "NoHint",
          "explanation": "When an address communicates with the Aave Protocol, a UserReserve is generated, with the user ID equal to the user's address plus the reserve's ID (which is the ERC20 token address).",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "graphql"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A UserReserve is generated, with the user ID equal to the user's address",
              "key": "A"
            },
            {
              "content": "A UserReserve is generated, with the user ID equal to the reserve's ID",
              "key": "B"
            },
            {
              "content": "A UserReserve is generated, with the user ID equal to the user's address plus the reserve's ID",
              "key": "C"
            },
            {
              "content": "No UserReserve is generated",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "078a4e4e-71e1-4e20-ad13-603502171e6c",
          "type": "MultipleChoice",
          "content": "Pick the correct statement(s) about the Aave's GraphQL queries.",
          "hint": "NoHint",
          "explanation": "All address values (for example, when used for id) must be in lowercase. In lowercase, the ID of reserves is the asset's address and the address of the market's LendingPoolAddressProvider. When utilizing the raw endpoints, the numeric number queried will be returned in either wei units (i.e. 10^18), the decimals of the asset itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "graphql"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "All address values (for example, when used for id) must be in uppercase.",
              "key": "A"
            },
            {
              "content": "All address values (for example, when used for id) must be in lowercase.",
              "key": "B"
            },
            {
              "content": "When utilizing the raw endpoints, the numeric number queried will be returned in wei units (i.e. 10^18) only.",
              "key": "C"
            },
            {
              "content": "When utilizing the raw endpoints, the numeric number queried will be returned in either wei units (i.e. 10^18), the decimals of the asset itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e950c0e1-a368-471f-8671-cc078c0b7571",
          "type": "SingleChoice",
          "content": "What is Goerli?",
          "hint": "NoHint",
          "explanation": "Goerli is an Ethereum test network that allows blockchain development testing prior to deployment on the main Ethereum network, Mainnet.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "graphql"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Data query language",
              "key": "A"
            },
            {
              "content": "An Ethereum test network",
              "key": "B"
            },
            {
              "content": "A decentralized protocol for indexing and querying data",
              "key": "C"
            },
            {
              "content": "A DeFi protocol",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "7441eb5f-68f3-40de-b12f-80dc17c80b2c",
          "shortTitle": "V2 Contracts",
          "details": "This video enables learners to know about\n  * AAVE\n  * Main protocol features\n  * What's new in v2 protocol\n  * Resources\n",
          "title": "Introduction to AAVE V2 Smart Contracts",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=AMAMvKc-O2s",
          "subTopics": []
        },
        {
          "uuid": "8b2485fe-7a9b-4dee-9e65-348c1dc7a66c",
          "shortTitle": "V3 contracts",
          "details": "This video enables learners to know about\n  * AAVE v3 features\n  * Build on top of AAVE\n",
          "title": "Introduction to AAVE V3 Smart Contracts",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=LzaS8IiqnPY",
          "subTopics": []
        }
      ],
      "summaries": [
        {
          "key": "aave-data-intro",
          "title": "Introduction",
          "shortTitle": "Introduction",
          "details": "* AAVE is a DeFi protocol that facilitates the lending and borrowing of cryptocurrency tokens using diverse algorithms and smart contracts without centralized intermediaries. \n* It is a non-custodial liquidity protocol that allows users to participate as lenders or borrowers. Depositors provide liquidity to the market to earn a passive income, while borrowers are able to borrow in an over-collateralized manner.\n* Aave's GraphQL data layer is a great resource for developers, allowing developers to access data that may not have been available otherwise. This way developers can work with more data and create more advanced applications. \n* Just like any decentralized blockchain application, Aave's data can be classified into three types: \n  - **Real-time data or current information** - This includes the current state and the new events. With real-time data, you can use data visualisations that reflect changes as they occur in real-time. This means that dashboards are interactive and accurate at any given moment.\n  - **Historical** - This includes past state and events. With historical data, you can get a snapshot of information displayed in a chart.\n\n* There are multiple use cases of this data provided by Aave and varied applications (including read-only as well as read/write applications) can be built on top of it and we can examine this data to gain insights on how to update and continue to improve the application.\n\n* The focus of this chapter will be to use Aave's data and show it on the UI in a couple of use cases. \n  - Creating a pie graph to review the Aave treasury in USDT \n  - Implementing a time series graph of how the holdings of different pools have changed over time.\n\n* **Importance of Analytics**\n  - Make informed decisions\n  - Improve efficiency\n  - Identify frauds\n  - Improve protocol governance\n  - Accelerate through uncertainty\n  - Tackle bugs and problems\n  - Transform raw data into more valuable information\n\n* Aave's data can be queried in the form of REST or GraphQL. Aave uses “The Graph” to index its data and anyone can query the subgraphs to get access to this information.\n"
        },
        {
          "title": "Realtime GraphQL Data",
          "shortTitle": "GraphQL",
          "key": "graphql",
          "details": "#### The Graph and GraphQL\n* The Graph is a decentralized protocol for indexing and querying data from Ethereum-based blockchains. That is, obtaining specific data from the blockchain is a more convenient approach while adhering to the web3 ethos and benefiting from decentralization and stability.\n\n* The underlying query language used in The Graph is GraphQL. What is the distinction between RESTFUL API calls and GraphQL calls? Traditional APIs, on the other hand, require developers to define unique endpoints for users that return specified data. If the user requires further information, they may need to make repeated API calls, potentially hundreds of API calls, to obtain it. As long as the developer has established a flexible schema, The Graph (which uses GraphQL) just requires one call to a subgraph.\n* See this [GraphQL primer](https://medium.com/graphprotocol/graphql-will-power-the-decentralized-web-d7443a69c69a) for additional information on The Graph and the underlying GraphQL.\n\n#### Source of Aave Subgraphs\n* To view the source of the subgraphs, see our [Github repo](https://github.com/aave/protocol-v2-subgraph).\n\nProduction Network: [Polygon](https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-polygon)\n\n#### How to Make Use of the Playground\n\n* If you use your browser to navigate to the above playground links, you will be directed to The Graph's playground, where you can simply write and test GraphQL queries.\n* Select the purple play button to run your query.\n* In the middle column, the query results will be returned.\n* Use the 'Schema' column on the right to see what data is available, which may be investigated to discover the underlying data.\n* You can also type in the left column and use the auto-complete feature to identify the appropriate query/types.\n\n#### Points to keep in mind\n* All address values (for example, when used for id) must be in lowercase.\n* In lowercase, the ID of reserves is the asset's address and the address of the market's LendingPoolAddressProvider.\n* When utilizing the raw endpoints, the numeric number queried will be returned in either wei units (i.e. 10^18), the decimals of the asset itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).\n* By default, each 'page' of results returns 100 entries. This is expandable to a maximum of 1000 entries per page.\n* To list the following 1000 entries, for example, put something like: (skip:1000, first: 1000) to your query's arguments.\n* This is also true for nested entries, such as arrays.\n\n* This Graph endpoint contains only static data. To obtain a user's most recent balance (including interest earned up to that moment), you must either compute it yourself or make a balanceOf() call to the aToken contract.\n\n| Return Data Type           | Subgraph Address                                                       |\n| -------------------------- | ---------------------------------------------------------------------- | \n| Mainnet                    | https://thegraph.com/explorer/subgraph/aave/aave-v2-matic              |\n| Görli (Goerli) Testnet     | https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-goerli   |\n\n* Goerli is an Ethereum test network that allows blockchain development testing prior to deployment on the main Ethereum network, Mainnet. Görli (Goerli) Testnet is the first proof-of-authority cross-client testnet, synching Parity Ethereum, Geth, Nethermind, Hyperledger Besu (formerly Pantheon), and EthereumJS. This testnet is a community-based project, completely open-source, naturally. It was born in September 2018 during ETHBerlin and has been growing in contributors ever since.\n\n#### Using your app to access GraphQL data\n\n* The preferred method is to utilize a client library that can handle the 'plumbing' to ensure you have up-to-date data (with caching sometimes included).  Apollo is used internally, but there are several choices depending on your programming language; read the official GraphQL page for more information.\n* If you are unable to utilize a client library (for example, while querying using Postman), you can send a POST request to our subgraph's HTTP endpoint with the header: \"Content-Type: application/json\" and the body comprising of your query on one line in quotations. As an example:\n```\n{\"query\": \"{ reserves (where: {usageAsCollateralEnabled: true})  { id name price {id} liquidityRate variableBorrowRate stableBorrowRate}}\" }\n```\n"
        },
        {
          "title": "Querying Aave's GraphQL database using React and implementing a Pie chart",
          "shortTitle": "React App",
          "key": "react-app",
          "details": "* **Initial Setup**\n  First, we create a React project, you can refer [this](https://create-react-app.dev/docs/getting-started/) documentation.\n  Run npm start to check if the project runs fine.\n\n* **Integrate ApolloClient**\n  Then we integrate the Apollo client library. We can install and setup the client using [this](https://www.apollographql.com/docs/react/get-started/) documentation.\n  We can use the sample code to fetch the data and test our setup.\n\n* **Initialize the ApolloClient**\n  With our dependencies already set up, we can now create an ApolloClient instance.\n  We start by importing the symbols we require from @apollo/client into index.js.\n  Next, we initialize ApolloClient by handing it a configuration object including the uri and cache fields.\n\n* **Connect the client to React**\n  We can connect Apollo Client to React with the ApolloProvider component. Similar to React's Context.Provider, ApolloProvider wraps our React app and places Apollo Client on the context, enabling us to access it from anywhere in our component tree.\n  In index.js, we wrap our React app with an ApolloProvider.\n\n* **Fetching data with useQuery**\n  After the ApolloProvider is hooked up, we can start requesting data with useQuery. The useQuery hook is a React hook that shares GraphQL data with your UI.\n  We can define the query we want to execute by wrapping it in the gql template literal.\n  Next, we define a component named DisplayGraphs that executes our GET_QUERY query with the useQuery hook:\n\n* **Implementing the Pie Chart**\n  Now, our aim is to create a pie chart using the data we receive. So now we use [react-chartjs-2](https://react-chartjs-2.js.org/). We will import it in our App.js.\n  Then we initialize our code to get a Pie chart. Finally we will add the code to get our Pie chart.\n\n* This will give us a Pie chart in our React app.\n* You can get the complete code [here](https://github.com/DoDAO-io/aava-analytics-sample-app).\n"
        },
        {
          "title": "Historical Rest Data",
          "shortTitle": "Historical Rest Data",
          "key": "historical-rest-data",
          "details": "* Now we will use the [Aave Protocol API](https://aave-api-v2.aave.com/) to create a time series graph.\n* We will use the same react application to create the time series graph too, so if you still haven't create a react app by following the previous steps.\n* Since the the [Aave Protocol API](https://aave-api-v2.aave.com/) is for v2 mainnet so now we need to query the Aave v2 mainnet subgraph.\n* We need to make the fetch requests from https://aave-api-v2.aave.com/#/data/get_data_rates_history to get the time series data for any Aave reserve. \n* If you visit the above link, you can see that we require a reserveID to fetch the data (there is a sample reserveID already provided in case you want to try it out). So to get this reserveID, we will query the Aave v2 mainnet subgraph (https://thegraph.com/hosted-service/subgraph/aave/protocol-v2 ). We have already queried the reserveIDs for ChainLink Token (0x514910771af9ca656af840dff83e8264ecf986ca0xb53c1a33016b2dc2ff3653530bff1848a515c8c5) and TrueUSD (0x0000000000085d4780b73119b644ae5ecd22b3760xb53c1a33016b2dc2ff3653530bff1848a515c8c5) which we will be using to plot the graph. \n* We query an array of objects which contains the pools with the reserves id, name and symbol.\n* Also, in the GET request we need to provide the start date (from) and time interval (resolutionInHours) to fetch the data. You can use [this](https://www.epochconverter.com/) UNIX timestamp convertor to change the date.\n* So now you can visit the aave protocol api and playaround with different reserveID, from and resolutionInHours.\n* Now, we visit our App.js and add some changes to code to get our desired graph and add some import statements as we need to use Line Chart this time to represent the time series data.\n* Now, we need to fetch the get requests so for that we will use the useEffect hook from React and store the data using useState hook. So add the following code to your DisplayGraphs functions.\n* The Get request also returns some unwanted data and the timestamp is in a format which we don't like much, so we update it.\n* Finally, we create the Line chart.\n* You can get the complete code [here](https://github.com/DoDAO-io/aava-analytics-sample-app). \n"
        }
      ]
    }
  ],
  "uuid": "aave-developer-1"
}